# Guide de mise à niveau vers la version 1.5

**Effectuez une sauvegarde avant la mise à niveau, puis exécutez la commande suivante pour mettre à niveau**
`composer require workerman/webman-framework ^1.5 -W && composer require webman/console ^1.2.12 && php webman install`

# Fonctionnalités et changements

Prise en charge du v5 de workerman [coroutines](https://www.workerman.net/doc/workerman/fiber.html)

> **Remarque**
> workerman v5 nécessite PHP>=8.1
> Pour mettre à niveau workerman, utilisez la commande `composer require workerman/workerman ^5.0.0 -W`
> Les coroutines Fiber nécessitent l'installation de `composer require revolt/event-loop ^1.0.0`

# Exemple
### Réponse différée

```php
<?php

namespace app\controller;

use support\Request;
use Workerman\Timer;

class TestController
{
    public function index(Request $request)
    {
        // Attendre 1,5 seconde
        Timer::sleep(1.5);
        return $request->getRemoteIp();
    }
}
```
`Timer::sleep()` est similaire à la fonction `sleep()` intégrée de PHP, mais contrairement à `sleep()`, `Timer::sleep()` ne bloque pas le processus.

### Lancement de requêtes HTTP

> **Remarque**
> Nécessite l'installation de `composer require workerman/http-client ^2.0.0`

```php
<?php

namespace app\controller;

use support\Request;
use Workerman\Http\Client;

class TestController
{
    public function index(Request $request)
    {
        static $client;
        $client = $client ?: new Client();
        $response = $client->get('http://example.com'); // Lancer une requête asynchrone de manière synchrone
        return $response->getBody()->getContents();
    }
}
```
De même, la requête `$client->get()` est non bloquante, ce qui peut être utilisé pour gérer de manière non bloquante les requêtes HTTP dans webman, améliorant ainsi les performances.

Pour plus d'informations, consultez [workerman/http-client](https://www.workerman.net/doc/workerman/components/workerman-http-client.html)

### Ajout de la classe support\Context

La classe support\Context est utilisée pour stocker les données relatives à la requête. Lorsque la requête est terminée, les données de contexte correspondantes sont automatiquement supprimées. Autrement dit, la durée de vie des données de contexte suit la durée de vie de la requête.

### Pollution des variables globales

Environnement de coroutine interdit de stocker des informations d'état **relatives à la requête** dans des variables globales ou statiques, car cela peut entraîner une pollution des variables globales, par exemple

```php
<?php

namespace app\controller;

use support\Request;
use Workerman\Timer;

class TestController
{
    protected static $name = '';

    public function index(Request $request)
    {
        static::$name = $request->get('name');
        Timer::sleep(5);
        return static::$name;
    }
}
```

En définissant le nombre de processus à 1, lorsque nous effectuons deux requêtes consécutives à
http://127.0.0.1:8787/test?name=lilei
http://127.0.0.1:8787/test?name=hanmeimei
Nous nous attendons à ce que les résultats de ces deux requêtes soient respectivement `lilei` et `hanmeimei`, mais en réalité, ils sont tous deux renvoyés comme `hanmeimei`.
Cela est dû au fait que la deuxième requête a écrasé la variable statique `$name`, donc lorsque la première requête se termine après le délai, la variable statique $name est déjà devenue `hanmeimei`.

**La méthode correcte consiste à stocker les données d'état de la requête dans le contexte**
```php
<?php

namespace app\controller;

use support\Request;
use support\Context;
use Workerman\Timer;

class TestController
{
    public function index(Request $request)
    {
        Context::set('name', $request->get('name'));
        Timer::sleep(5);
        return Context::get('name');
    }
}
```

**Les variables locales ne causent pas de pollution des données**
```php
<?php

namespace app\controller;

use support\Request;
use support\Context;
use Workerman\Timer;

class TestController
{
    public function index(Request $request)
    {
        $name = $request->get('name');
        Timer::sleep(5);
        return $name;
    }
}
```
Étant donné que $name est une variable locale, les coroutines ne peuvent pas accéder aux variables locales les unes des autres, donc l'utilisation de variables locales est sûre en termes de coroutines.

# À propos des coroutines
Les coroutines ne sont pas une solution miracle, leur introduction signifie qu'il est nécessaire de faire attention à la pollution des variables globales / statiques, et qu'il est nécessaire de configurer le contexte. De plus, le débogage des bugs dans un environnement de coroutine est plus complexe que dans une programmation bloquante.

En réalité, la programmation bloquante de webman est déjà assez rapide. Selon les données de benchmark des trois dernières années de [techempower.com](https://www.techempower.com/benchmarks/#section=data-r21&l=zijnjz-6bj&test=db&f=1ekg-cbcw-2t4w-27wr68-pc0-iv9slc-0-1ekgw-39g-kxs00-o0zk-4fu13d-2x8do8-2), la programmation bloquante de webman avec des activités de base de données est presque 2 fois plus performante que le framework web Go, comme gin et echo, et presque 40 fois plus performante que le framework traditionnel Laravel.
![](../../assets/img/benchemarks-go-sw.png?)

Lorsque la base de données, Redis, etc., sont en intranet, la programmation bloquante multi-processus a souvent des performances supérieures à celles des coroutines, car lorsque la base de données, Redis, etc., sont suffisamment rapides, le coût de création, de planification et de destruction de coroutines peut être plus élevé que le coût de bascule de processus. Par conséquent, l'introduction de coroutines ne permet pas d'améliorer significativement les performances dans ces cas.

# Quand utiliser les coroutines
Lorsque l'application comporte des accès lents, par exemple lorsqu'elle doit accéder à une interface tierce, vous pouvez utiliser [workerman/http-client](https://www.workerman.net/doc/workerman/components/workerman-http-client.html) pour lancer des appels HTTP asynchrones de manière asynchrone, améliorant ainsi la capacité de concurrence de l'application.
