# 1.5 Güncelleme Kılavuzu

**Yedekleme yapmadan önce lütfen yükseltme işlemini aşağıdaki komutla gerçekleştirin:**
`composer require workerman/webman-framework ^1.5 -W && composer require webman/console ^1.2.12 && php webman install`

# Özellikler ve Değişiklikler

workerman v5 [korutinlere](https://www.workerman.net/doc/workerman/fiber.html) olanak sağlar

> **Not**
> workerman v5 PHP>=8.1 gerektirir
> workerman yükseltme komutu `composer require workerman/workerman ^5.0.0 -W`
> Fiber korutinleri yüklemek için `composer require revolt/event-loop ^1.0.0` gerekir

# Örnekler
### Gecikmeli Yanıt

```php
<?php

namespace app\controller;

use support\Request;
use Workerman\Timer;

class TestController
{
    public function index(Request $request)
    {
        // 1.5 saniye uyuma
        Timer::sleep(1.5);
        return $request->getRemoteIp();
    }
}
```
`Timer::sleep()` PHP'nin yerleşik `sleep()` işlevine benzer, farkı ise `Timer::sleep()` işlemin süreci bloke etmemesidir.


### HTTP İsteği Yapma

> **Not**
> `composer require workerman/http-client ^2.0.0` kurulumu gerektirir

```php
<?php

namespace app\controller;

use support\Request;
use Workerman\Http\Client;

class TestController
{
    public function index(Request $request)
    {
        static $client;
        $client = $client ?: new Client();
        $response = $client->get('http://example.com'); // Eşzamansız isteği sendika metodu
        return $response->getBody()->getContents();
    }
}
```
Aynı şekilde `$client->get()` isteği bloke etmeyen bir işlemdir, bu, webman içinde HTTP isteklerini bloke etmeyen bir şekilde işlemek için kullanılabilir.

Daha fazla bilgi için [workerman/http-client](https://www.workerman.net/doc/workerman/components/workerman-http-client.html)'a bakın.

### support\Context Sınıfı Ekleme

support\Context sınıfı isteğe bağlı verilerin depolanması için kullanılır, istek tamamlandığında ilgili bağlam verisi otomatik olarak silinir. Yani bağlam veri ömrü istek ömrü ile aynıdır.

### Global Değişken Kirliliği

Korutin ortamında, **isteğe özgü** durum bilgilerini global değişken veya statik değişken içinde saklamak yasaktır, çünkü bu global değişken kirliliğine yol açabilir, örneğin:

```php
<?php

namespace app\controller;

use support\Request;
use Workerman\Timer;

class TestController
{
    protected static $name = '';

    public function index(Request $request)
    {
        static::$name = $request->get('name');
        Timer::sleep(5);
        return static::$name;
    }
}
```

İşlem sayısını 1 olarak ayarladığımızda, ardışık iki istek gönderdiğimizde
http://127.0.0.1:8787/test?name=lilei
http://127.0.0.1:8787/test?name=hanmeimei
İki isteğin sırasıyla `lilei` ve `hanmeimei` döndürmesini bekleriz, ancak gerçekte dönen her ikisi de de `hanmeimei`dir.
Bu, ikinci istekin statik değişken `$name`'i üzerine yazması nedeniyle gerçekleşir, ilk isteğin uyku süresi sona erdiğinde, statik değişken `$name` zaten `hanmeimei` haline gelmiştir.

**Doğru olan yaklaşım, istek durum verilerini bağlam içinde depolamaktır:**
```php
<?php

namespace app\controller;

use support\Request;
use support\Context;
use Workerman\Timer;

class TestController
{
    public function index(Request $request)
    {
        Context::set('name', $request->get('name'));
        Timer::sleep(5);
        return Context::get('name');
    }
}
```

**Yerel değişkenler veri kirliliğine neden olmaz:**
```php
<?php

namespace app\controller;

use support\Request;
use support\Context;
use Workerman\Timer;

class TestController
{
    public function index(Request $request)
    {
        $name = $request->get('name');
        Timer::sleep(5);
        return $name;
    }
}
```
Çünkü `$name` yerel bir değişken olduğundan, korutinler arasında yerel değişkenlere erişilemediğinden, yerel değişken kullanmak korutin güvenliğidir.

# Korutin Hakkında
Korutinler bir gümüş kurşun değildir, korutinleri içermek, global değişken/statik değişken kirliliği sorununa dikkat edilmesi ve bağlam bağlamının ayarlanması gerektiği anlamına gelir. Ayrıca, korutin ortamında hata ayıklama, engellenmiş programlamadan daha karmaşıktır.

webman engellenmiş programlama pratiğinde zaten oldukça hızlıdır, son üç yılın [techempower.com](https://www.techempower.com/benchmarks/#section=data-r21&l=zijnjz-6bj&test=db&f=1ekg-cbcw-2t4w-27wr68-pc0-iv9slc-0-1ekgw-39g-kxs00-o0zk-4fu13d-2x8do8-2) basınç testi verilerine göre, webman engellenmiş programlama, veritabanı işlevi olan web çerçevesi olan gin, echo vb. gibi go web çerçevelerinden neredeyse 2 kat daha performanslıdır ve geleneksel çerçeve olan 40 kat daha performanslıdır.

![](../../assets/img/benchemarks-go-sw.png?)

Veritabanı, redis gibi şeylerin yerel ağda bulunduğu durumlarda, çok işlemli engellenmiş programlamanın performansı genellikle korutinlerden daha iyidir, çünkü veritabanı, redis vb. yeterince hızlı olduğunda, korutin oluşturma, planlama ve yok etme maliyeti genellikle işlem değiştirme maliyetinden daha yüksektir, bu nedenle bu durumda korutinlerin performansı göze çarpmaz.

# Korutin Ne Zaman Kullanılır
İşte sorgu süresi olan bir işiniz varsa, örneğin, işletme bir üçüncü taraf arabirime başvuruyorsa, asenkron HTTP çağrısı yapmak için [workerman/http-client](https://www.workerman.net/doc/workerman/components/workerman-http-client.html) kullanılabilir, uygulama eş zamanlı yeteneğini artırabilir.
