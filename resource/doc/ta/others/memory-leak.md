# உள்ளடக்க தன்மை அழிவுப் பற்றி
webman ஒரு நிரப்பப்பட்ட நினைவுவடிவம் மற்றும் நிரப்பப்பட்ட உள்ளடக்கத்தில் நாம் கூட்டுமிடத்தை சிலவற்றைச் சம்பாளிப்போம், எனவே நம்பகப்படாது. கணக்கீட்டில் தவறு ஏற்படும் மட்டுமே பெரும்பாலானவற்றில் அப்படியே இருக்கும் மேலும் அதில் பிடி எடுக்க முடியவிருக்கும். வறண்டியில்லா முறைகளில் webman மேம்படுத்துபவோன் உங்கள் வேலைச் செயல்பாட்டில் எதையும் மாற்ற தகுதியளிக்க உதவுகிறது.
> **குறிப்பு**
> webman அடிவானது மாற்றப்பட்ட நிலையுடன் அனைத்து செயல்பாட்டுகளுக்கும் உள்ளமைவுப் பயன்பாட்டைக் கண்டுபிடிக்கும், செயல்பாட்டில் எந்த மாற்றங்களையும் வழங்கவில்லை.

## உள்ளடக்க தன்மை அழிவுப் பற்றிய வெளியீடு
கேள்வியான எனதுக்குரியதால், விகிதமான வடிவத்தின் மூலம் webman பயன்படுத்தப்படும் மேலான உள்ளடக்கத்தைப் பிடியப்பட வேண்டிய பரிமாணங்கள் உள்ளன (எனவே **எப்போதும் மிகுந்தபட்சமாக அத் துவங்கவேண்டும்** என்பதைப் பார்க்கலாம்) மேலும் இதைத் தடுக்கவேண்டியது எவ்வாறு என்னவென திரை அமைப்பில் முன்பும் சொல்லப்பட்டுள்ளது. webman செயல்படுத்தும் பிளவு(php.ini இல் உள்ள `memory_limit` அமைப்பில் முதுகமையுடன் எதிர்காலமற்ற முன்னிலையில் உள்ளது) உள்ளடக்கத்தை தானியங்கி மீட்டமைக்கும். நிரப்பப்படும் உள்ளடக்கம் மூலம் எல்லா செயல்பாட்டிலும் எப்போதும் மாற்றம் ஏற்படாது.

## உள்ளடக்க தன்மை அழிவு எப்படி ஏற்படுகிறது
**உள்ளடக்க தன்மை அழிவு நிர்வாகங்கள் கீழ்காணும் இரண்டு குண்டுகளை பொருத்த வேண்டும்:**
1. வேறுபாடுபட்டமாகவும் **நீளமான உத்திரமிடத்தைப்** பொருத்தமாகவும் உள்ளடக்கக்காக (கவனிக்கவும் **நீளமான உத்திரமிடத்தைப்** பொருத்தமாகவும் உள்ளடக்கக்காக) அமைக்கப்பட்ட முக்கியமான அணுகலானது. 
2. மேலும், இந்த **நீளமான உத்திரமிடத்தில்** எந்தவொரு முடிவுகளையும் சுத்தம் செய்யாமல் அவசியமற்றுப் புதிய தரவுகளைச் சேர்க்காமல் திருத்திய வைக்க அனுமதிக்கப்பட்டுள்ளது. 

1 2 குண்டுகள் *ஒப்புமையாக உள்ள பொருள்கள்* **ஒலி மாறும்** என்பதை பெற்றால், உள்ளடக்க தன்மை அழிவு ஏற்படும். முக்கியமாக, மேலே குண்டுகளின் எல்லைகளை பெற்றுக்கொள்ளுங்கள் அல்லது ஒரு குண்டைக் கடையாளுதல் மட்டுமே பெற்றுக்கொள்ளுங்கள்; இப்படியாக அடுத்த வழு இல்லை என்பதை கண்டறிதலாம். மறுபடி, இருப்பினும், மேல்வழியில் ஒரு குண்டுகளும் அல்லது ஒரு குண்டைக் கடையாளும்தலில் உள்ளடக்கத்தை கேட்டால், உள்ளடக்க தன்மை அழிவால்தன்மை ஏற்படாது.
## நீண்ட உயர்நீள பட்டியல்

வெப்மேன் உள்ள நீண்ட உயர்நீள பட்டியல்கள் பின்னர் குறிப்பிடுவார்கள்:
1. ஸ்டேட்டிக் சொந்தப்படுத்தல் பட்டியல்
2. ஒற்றுமை பட்டியல் பணி
3. குரோபல் சொந்தப்படுத்தல் பட்டியல்

> **குறிச்சொல்**
> வெப்மேனில் உயர்நீள தரப்பட்டதும் பயன்படுத்த விரும்புகிறது, ஆனால் அதன் அளவு எண்ணிக்கை முதலில் இருக்கக்கூடியதாக இருக்க வேண்டும். அங்கீகரிக்கப்பட்டமைவான எண்ணிக்கையுடன் அதன் பட்டியல் விரிவடிக்கப்படாது.

பின்கொடுக்கப்படும் உதாரணங்களைப் பயன்படுத்தி விளக்கிக்கொள்கின்றோம்

#### வளரப்படுகின்ற ஸ்டேட்டிக் பட்டியல்
```php
class Foo
{
    public static $data = [];
    public function index(Request $request)
    {
        self::$data[] = time();
        return response('hello');
    }
}
```

`ஸ்டேட்டிக்` முடியும் ஒரு `டேட்டா` பட்டியல் உயர்நீளமாகும், மேலும் உருவாக்க உதாரணத்தில் $தரப்பட்டியல் கோப்பில் கேவலமாகிவிட்டுள்ளது `படைப்படுத்தவட்டவேண்டும்` அனுபதிய ஏற்படும் வரை. 

#### வளரப்படுகின்ற ஒற்றுமை பட்டியல் பணி
```php
class Cache
{
    protected static $instance;
    public $data = [];
    
    public function instance()
    {
        if (!self::$instance) {
            self::$instance = new self;
        }
        return self::$instance;
    }
    
    public function set($key, $value)
    {
        $this->data[$key] = $value;
    }
}
```

அழைப்பு குறிப்பிட்டது
```php
class Foo
{
    public function index(Request $request)
    {
        Cache::instance()->set(time(), time());
        return response('hello');
    }
}
```

சேமிப்பக்கம் :: இன்ஸ்டன்ஸ் () ஒரு Cache ஒற்றுமை தரவைக் குறிப்பிடுகின்றது, அது ஒரு நீண்ட உயர்நீள வகையான கருவியாகும். இதன் மூலம் $தரப்பட்டியல் அணுகும் arrayஐ மீண்டும் மீண்டும் எழுதி மேம்படுத்தினால் உருவாக்கப்படாது, தரவுகளைச் சேமித்தலைவிட, அது மிகப் பெரும் பயனுள்ள நீள்தரப்பு முறையாகும். விண்ணப்ப குறிச்சொல் Cache :: இன்ஸ்டன்ஸ் ()-> set (key, value) keyஅன்றுvalueஐ சேர்ப்பதற்கு பயன்படுத்தப்பட்டால் தரவுகள் மட்டுமே பயன்படுத்தமுடியும் என்பது விளக்கப்படாது.

> **குறிச்சொல்**
> Cache :: இன்ஸ்டன்ஸ் இல் ()-> set (key, value) கேள்விப்படுத்தல், மிகுந்த எண்ணிக்கை உள்ள keyக்காக valueஐ சேர்ப்பதற்கு அது முடியும், ஆகையால் தரவு அடைப்பதற்கு பயன்படும் என்பது விளக்கமாக இருக்காது.

#### வளரப்படுகின்ற globalபட்டி
```php
class Index
{
    public function index(Request $request)
    {
        global $data;
        $data[] = time();
        return response($foo->sayHello());
    }
}
```
globalகுறிப்பிட்டது பட்டியலுக்கு மட்டுமே செல்லுபடும் பின்னர் செயல்பாட்டின் படுத்தியில் மறுமையில் நிரம்பும், அது நீண்ட உயர்நீளமான பட்டியலாகும். மேலும் செயல்பாட்டின் படுத்தியில் staticமூலம் உருவாக்கப்பட்டதாகவும் $பட்டியல்களை நீண்ட உயர்நீளமாகும் பட்டியலுக்கு பயன்படுத்தப்படும், மேலும் பட்டியல்களை எழுதி மேம்படுத்தும் போது மீண்டும் மீண்டும் எழுதினால் உருவாகப்படாது. 

புதிய முறையில் ஒரு வரிசை குறிப்பிட்ட #include<class_name> முடியும். அப்படி இடது பக்கம்:
```php
class Index
{
    public function index(Request $request)
    {
        static $data = [];
        $data[] = time();
        return response($foo->sayHello());
    }
}
```
## பரிந்துரைகள்
மேலும் நிரப்பப்பட்டால், உள்ளிட்ட குறிப்புகளை கவனித்தவர்களுக்கு ஆகும், அது பரவலாக ஏற்படுகிறது, மேலும் அதனால் எப்படி தவறுதல் ஏற்பட்டதை கண்டறிய நாம் ஆய்வுபெடெஸ்ட் மூலம் காண்பிப்பது முடியும், ஆகையால் தொடரும் பிழைகளை கண்டறி பிரச்சினை கண்டுபிடிப்பதும் வரும். கண்டன பிழைகளை நாம் எதிர்பார்க்கி வர முடியாது என்றால், அந்த நிறுவலின் தானாக்கப்பட்ட சேவையைக் கொண்டுவந்துள்ள webman மேம்படுத்தப்பட்டிருக்கும் நெடுவரிசை சேவையைப் பொறுத்திக்கொடுக்கும், அது நினைவகமாக மாறும்.

நிச்சயமாக நீங்கள் நிராகரிக்க விரும்புகின்றீர்களானால், கீழே பரிந்துரைகளை பார்க்கலாம்.
1. `global`, `static` முடிவுச் சொல்லைப் பயன்படுத்தாமல் முடிவில்லையான வரலாறுபடுத்துகிறவைகளைப் பயன்படுத்துவதைத் தவிர்க்கவும்
2. உங்களால் அறியாத வகையில் வருவாயில்லாத வகைகளுக்கு ஒற்றுமைப்படுத்தாமல், `new` சொல்லைப் பயன்படுத்தவும். ஒரு ஒற்றை தேவைப்படும்என்றால், அதுணைமைக்குரிய வரலாறுபடுத்தும் பண்படுத்துனர் ஓர் வாரிசுக்களைப் பார்க்கவும்
