# Hướng dẫn Nâng cấp 1.5

**Lưu ý sao lưu trước khi nâng cấp và thực hiện các lệnh sau để nâng cấp**

`composer require workerman/webman-framework ^1.5 -W && composer require webman/console ^1.2.12 && php webman install`

# Tính năng và Thay đổi

Hỗ trợ workerman v5 [Coroutine](https://www.workerman.net/doc/workerman/fiber.html)

> **Ghi chú**
> workerman v5 yêu cầu PHP >= 8.1
> Lệnh nâng cấp workerman `composer require workerman/workerman ^5.0.0 -W`
> Coroutine cần cài đặt `composer require revolt/event-loop ^1.0.0`

# Ví dụ
### Phản hồi trễ

```php
<?php

namespace app\controller;

use support\Request;
use Workerman\Timer;

class TestController
{
    public function index(Request $request)
    {
        // Ngủ 1.5 giây
        Timer::sleep(1.5);
        return $request->getRemoteIp();
    }
}
```
`Timer::sleep()` tương tự như hàm `sleep()` có sẵn trong PHP, khác biệt ở chỗ `Timer::sleep()` không chặn tiến trình.

### Gửi yêu cầu HTTP

> **Lưu ý**
> Cần cài đặt composer require workerman/http-client ^2.0.0

```php
<?php

namespace app\controller;

use support\Request;
use Workerman\Http\Client;

class TestController
{
    public function index(Request $request)
    {
        static $client;
        $client = $client ?: new Client();
        $response = $client->get('http://example.com'); // Gửi yêu cầu bất đồng bộ theo cách đồng bộ
        return $response->getBody()->getContents();
    }
}
```
Tương tự, yêu cầu `$client->get()` không chặn tiến trình, điều này có thể được sử dụng trong webman để xử lý yêu cầu HTTP không chặn tiến trình, từ đó tăng hiệu suất.

Xem thêm tại [workerman/http-client](https://www.workerman.net/doc/workerman/components/workerman-http-client.html)

### Thêm lớp support\Context 

Lớp support\Context  được sử dụng để lưu trữ dữ liệu liên quan đến yêu cầu, khi yêu cầu hoàn thành, dữ liệu context tương ứng sẽ tự động bị xóa. Nghĩa là vòng đời của dữ liệu context theo vòng đời của yêu cầu.

### Ô nhiễm biến toàn cục

Trong môi trường Coroutine, cấm lưu trạng thái liên quan đến yêu cầu trong biến toàn cục hoặc biến tĩnh, vì điều này có thể dẫn đến ô nhiễm biến toàn cục, ví dụ

```php
<?php

namespace app\controller;

use support\Request;
use Workerman\Timer;

class TestController
{
    protected static $name = '';

    public function index(Request $request)
    {
        static::$name = $request->get('name');
        Timer::sleep(5);
        return static::$name;
    }
}
```

Thiết lập số tiến trình là 1, khi chúng ta liên tục gửi hai yêu cầu
http://127.0.0.1:8787/test?name=lilei  
http://127.0.0.1:8787/test?name=hanmeimei  
Chúng ta mong đợi kết quả trả về của hai yêu cầu lần lượt là `lilei` và `hanmeimei`, nhưng thực tế, cả hai đều trả về `hanmeimei`.
Điều này xảy ra vì yêu cầu thứ hai ghi đè biến tĩnh `$name`, khi thời gian ngủ của yêu cầu thứ nhất kết thúc thì biến tĩnh `$name` đã trở thành `hanmeimei`.

**Cách hoạt động đúng là sử dụng context để lưu trạng thái yêu cầu**
```php
<?php

namespace app\controller;

use support\Request;
use support\Context;
use Workerman\Timer;

class TestController
{
    public function index(Request $request)
    {
        Context::set('name', $request->get('name'));
        Timer::sleep(5);
        return Context::get('name');
    }
}
```

**Biến cục bộ không gây ra ô nhiễm dữ liệu**
```php
<?php

namespace app\controller;

use support\Request;
use support\Context;
use Workerman\Timer;

class TestController
{
    public function index(Request $request)
    {
        $name = $request->get('name');
        Timer::sleep(5);
        return $name;
    }
}
```
Bởi vì `$name` là biến cục bộ, Coroutine không thể truy cập các biến cục bộ của nhau, vì vậy việc sử dụng biến cục bộ là an toàn trong môi trường Coroutine.

# Về Coroutine
Coroutine không phải là phương án hoàn hảo, việc áp dụng Coroutine đồng nghĩa với việc cần chú ý tới vấn đề ô nhiễm biến cục bộ/biến tĩnh và cần thiết lập ngữ cảnh context. Ngoài ra, việc gỡ lỗi lỗi trong môi trường Coroutine cũng phức tạp hơn so với lập trình theo kiểu chặn.

Lập trình theo kiểu chặn trong webman thực sự đã đủ nhanh, dựa trên dữ liệu thử nghiệm từ [techempower.com](https://www.techempower.com/benchmarks/#section=data-r21&l=zijnjz-6bj&test=db&f=1ekg-cbcw-2t4w-27wr68-pc0-iv9slc-0-1ekgw-39g-kxs00-o0zk-4fu13d-2x8do8-2) trong ba vòng thử nghiệm gần đây, webman lập trình theo kiểu chặn với dịch vụ cơ sở dữ liệu có hiệu suất gần gấp đôi so với framework web go như gin, echo và có hiệu suất gấp gần 40 lần so với framework truyền thống như laravel. ![](../../assets/img/benchemarks-go-sw.png?)

Khi cả cơ sở dữ liệu và redis đều ở trong mạng nội bộ, hiệu suất lập trình theo kiểu chặn có thể thường cao hơn so với Coroutine, do khi cơ sở dữ liệu, redis đủ nhanh, chi phí tạo, lập lịch và hủy Coroutine có thể lớn hơn chi phí chuyển đổi tiến trình, vì vậy, việc áp dụng Coroutine không thể tối ưu hóa hiệu suất đáng kể.

# Khi nào sử dụng Coroutine
Khi trong kinh doanh có truy cập chậm, ví dụ khi cần truy cập API của bên thứ ba, có thể sử dụng [workerman/http-client](https://www.workerman.net/doc/workerman/components/workerman-http-client.html) để gửi yêu cầu HTTP bất đồng bộ theo cách Coroutine, từ đó tăng khả năng đồng thời của ứng dụng.
