# Guía de actualización 1.5

**Haga una copia de seguridad antes de actualizar, ejecute el siguiente comando para actualizar**
`composer require workerman/webman-framework ^1.5 -W && composer require webman/console ^1.2.12 && php webman install`

# Características y cambios

Soporte para workerman v5 [fibras](https://www.workerman.net/doc/workerman/fiber.html)

> **Consejo**
> workerman v5 requiere PHP>=8.1
> Comando de actualización de workerman `composer require workerman/workerman ^5.0.0 -W`
> Se necesita instalar fibra con `composer require revolt/event-loop ^1.0.0`

# Ejemplos
### Respuesta tardía

```php
<?php

namespace app\controller;

use support\Request;
use Workerman\Timer;

class TestController
{
    public function index(Request $request)
    {
        // Espera 1.5 segundos
        Timer::sleep(1.5);
        return $request->getRemoteIp();
    }
}
```
`Timer::sleep()` es similar a la función `sleep()` incorporada de PHP, la diferencia es que `Timer::sleep()` no bloqueará el proceso.


### Realizar una solicitud HTTP

> **Nota**
> Se necesita instalar `composer require workerman/http-client ^2.0.0`

```php
<?php

namespace app\controller;

use support\Request;
use Workerman\Http\Client;

class TestController
{
    public function index(Request $request)
    {
        static $client;
        $client = $client ?: new Client();
        $response = $client->get('http://example.com'); // Solicitud asíncrona usando un método sincrónico
        return $response->getBody()->getContents();
    }
}
```
De igual manera, la solicitud `$client->get()` es no bloquenate, esto puede utilizarse para manejar solicitudes http no bloqueantes en webman, mejorando el rendimiento.

Para más información, consulte [workerman/http-client](https://www.workerman.net/doc/workerman/components/workerman-http-client.html)

### Se agregó la clase support\Context

La clase support\Context se utiliza para almacenar datos relacionados con la solicitud, cuando la solicitud se completa, los datos de contexto correspondientes se eliminarán automáticamente. Esto significa que el ciclo de vida de los datos de contexto sigue el ciclo de vida de la solicitud.

### Contaminación de variables globales

En un entorno de transferencia, se prohíbe almacenar información de estado **relacionada con la solicitud** en variables globales o estáticas, ya que esto puede provocar la contaminación de variables globales, por ejemplo

```php
<?php

namespace app\controller;

use support\Request;
use Workerman\Timer;

class TestController
{
    protected static $name = '';

    public function index(Request $request)
    {
        static::$name = $request->get('name');
        Timer::sleep(5);
        return static::$name;
    }
}
```

Si configuramos el número de procesos como 1, cuando realizamos dos solicitudes consecutivas  
http://127.0.0.1:8787/test?name=lilei  
http://127.0.0.1:8787/test?name=hanmeimei  
Esperaríamos que los resultados de las dos solicitudes sean respectivamente `lilei` y `hanmeimei`, pero en realidad ambos resultados son `hanmeimei`.
Esto se debe a que la segunda solicitud sobrescribe la variable estática `$name`, cuando la primera solicitud finaliza el tiempo de espera, la variable estática `$name` ya se ha convertido en `hanmeimei`.

**El método correcto sería usar el almacenamiento de estado de la solicitud en context**
```php
<?php

namespace app\controller;

use support\Request;
use support\Context;
use Workerman\Timer;

class TestController
{
    public function index(Request $request)
    {
        Context::set('name', $request->get('name'));
        Timer::sleep(5);
        return Context::get('name');
    }
}
```

**Las variables locales no provocarán la contaminación de los datos**
```php
<?php

namespace app\controller;

use support\Request;
use support\Context;
use Workerman\Timer;

class TestController
{
    public function index(Request $request)
    {
        $name = $request->get('name');
        Timer::sleep(5);
        return $name;
    }
}
```
Porque `$name` es una variable local, las transferencias no pueden acceder mutuamente a las variables locales, por lo que el uso de variables locales es seguro en el entorno de transferencia.

# Acerca de las transferencias
Los transferencias no son una solución universal, su introducción significa que es necesario prestar atención a la contaminación de variables globales/estáticas y es necesario establecer un contexto.

Además, solucionar errores de depuración en un entorno de transferencia es un poco más complicado que la programación de bloqueo.

La programación de bloqueo en webman ya es lo suficientemente rápida, según los resultados de las pruebas de carga de las tres rondas en los últimos 3 años en [techempower.com](https://www.techempower.com/benchmarks/#section=data-r21&l=zijnjz-6bj&test=db&f=1ekg-cbcw-2t4w-27wr68-pc0-iv9slc-0-1ekgw-39g-kxs00-o0zk-4fu13d-2x8do8-2), la programación de bloqueo en webman con negocios de bases de datos tiene un rendimiento casi el doble que los frameworks web en go como gin, echo, etc., y es casi 40 veces más rápido que el marco tradicional laravel.
![](../../assets/img/benchemarks-go-sw.png?)

Cuando la base de datos, redis, etc. se encuentran en la red interna, es posible que la programación de transferencia y rendimiento multiproceso sea mayor que la programación de bloqueo. Esto se debe a que, cuando la base de datos, redis, etc. son suficientemente rápidos, el costo de creación, programación y eliminación de las transferencias puede ser mayor que el costo de cambio de proceso, por lo que en estos casos, la introducción de transferencias no mejora significativamente el rendimiento.

# Cuándo usar transferencias
Cuando hay consultas lentas en el negocio, como cuando es necesario acceder a una interfaz de terceros, se puede utilizar una llamada asíncrona HTTP en forma de transferencia utilizando [workerman/http-client](https://www.workerman.net/doc/workerman/components/workerman-http-client.html), mejorando la capacidad de concurrencia de la aplicación.
