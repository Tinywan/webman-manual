# 메모리 누수에 대한 내용
webman은 상주 메모리 프레임워크이므로 메모리 누수에 대해 약간 주의해야 합니다. 그러나 개발자가 지나치게 걱정할 필요는 없습니다. 메모리 누수는 매우 극단적인 조건에서 발생하며 쉽게 피할 수 있습니다. webman 개발은 전통적인 프레임워크 개발과 기본적으로 거의 동일하며 메모리 관리에 대한 추가 조작이 필요하지 않습니다.

> **팁**
> webman의 내장 모니터 프로세스는 모든 프로세스의 메모리 사용 상황을 모니터하며, 프로세스가 php.ini에 설정된 'memory_limit' 값에 거의 도달하면 해당 프로세스를 안전하게 다시 시작하여 메모리를 해제합니다. 이 기간 동안 비즈니스에는 영향을 미치지 않습니다.

## 메모리 누수 정의
요청이 계속 들어오면 webman이 사용하는 메모리도 **무한히 증가합니다**(주의할 점은 **무한히 증가합니다**), 수백 메가바이트 또는 그 이상이 될 수 있습니다. 이것이 메모리 누수입니다. 메모리가 증가하는 것은 메모리 누수가 아닙니다.

일반적으로 프로세스가 수십 메가바이트의 메모리를 사용하는 것은 매우 정상적인 상황이며, 프로세스가 매우 큰 요청을 처리하거나 대량의 연결을 유지하는 경우 단일 프로세스의 메모리 사용량은 100M에 달할 수도 있습니다. 이 부분의 메모리 사용 후에도 php는 모든 메모리를 다시 반환하지 않을 수 있습니다. 대신에 재사용하기 때문에 어떤 큰 요청을 처리한 후에 메모리 사용량이 증가하고 메모리가 해제되지 않는 경우는 정상적인 현상입니다. (gc_mem_caches() 함수를 호출하여 일부 빈 메모리를 해제할 수 있습니다)


## 메모리 누수가 발생하는 방법
**메모리 누수는 다음 두 가지 조건을 동시에 충족해야합니다:**
1. **장수명의 배열**이 존재해야합니다(주의: 일반 배열은 아닙니다)
2. 그 **장수명의** 배열은 무한히 증가해야합니다(비즈니스가 그것에 무한히 데이터를 삽입하고 데이터를 정리하지 않습니다)

만약 1, 2 조건을 **동시에 충족한다면**(주의: 동시에 충족한다면) 메모리 누수가 발생할 것입니다. 그렇지 않으면 위의 조건을 충족하지 않거나 둘 중 하나만 충족하지 않으면 메모리 누수가 아닙니다.


## 장수명의 배열

webman에서의 장수명 배열은 다음과 같습니다:
1. static 키워드 배열
2. 단일 배열 속성

> **참고**
> webman에서는 장수명의 데이터를 사용할 수 있지만 데이터 내의 요소가 한정되어 있고 요소 개수가 무한히 증가하지 않는 것을 보장해야 합니다.


아래는 각각의 예시입니다

#### 무한히 증가하는 static 배열
```php
class Foo
{
    public static $data = [];
    public function index(Request $request)
    {
        self::$data[] = time();
        return response('hello');
    }
}
```

`static` 키워드로 정의된 `$data` 배열은 장수명의 배열이며, 예시에서 `$data` 배열은 요청이 계속 들어올 때마다 계속 커지므로 메모리 누수가 발생합니다.

#### 무한히 증가하는 단일 배열 속성
```php
class Cache
{
    protected static $instance;
    public $data = [];
    
    public function instance()
    {
        if (!self::$instance) {
            self::$instance = new self;
        }
        return self::$instance;
    }
    
    public function set($key, $value)
    {
        $this->data[$key] = $value;
    }
}
```

호출 코드
```php
class Foo
{
    public function index(Request $request)
    {
        Cache::instance()->set(time(), time());
        return response('hello');
    }
}
```

`Cache::instance()`는 단일 인스턴스를 반환하며, 이는 장수명의 클래스 인스턴스입니다. 그 클래스의 `$data` 속성은 `static` 키워드를 사용하지는 않지만 클래스 자체가 장수명의 생애주기이기 때문에 `$data`도 장수명의 배열입니다. `$data` 배열에 계속 다른 키의 데이터를 추가하면 프로그램이 점점 더 많은 메모리를 사용하면서 메모리 누수가 발생합니다.

> **참고**
> Cache::instance()->set(key, value)에 추가되는 key가 유한하다면 메모리 누수가 발생하지 않습니다. 따라서 `$data` 배열은 무한히 증가하지 않기 때문입니다.

#### 무한히 증가하는 global 배열
```php
class Index
{
    public function index(Request $request)
    {
        global $data;
        $data[] = time();
        return response($foo->sayHello());
    }
}
```
global 키워드로 정의된 배열은 함수나 클래스 메서드 실행 후에 회수되지 않기 때문에 장수명의 배열입니다. 위의 코드는 계속해서 요청이 들어올 때마다 메모리 누수가 발생합니다. 마찬가지로 함수나 메서드 내에서 static 키워드로 정의된 배열도 장수명의 배열이며, 배열이 무한히 증가하면 메모리 누수가 발생합니다. 예를 들어:

```php
class Index
{
    public function index(Request $request)
    {
        static $data = [];
        $data[] = time();
        return response($foo->sayHello());
    }
}
```

## 권장사항
메모리 누수에 너무 관심을 두지 않는 것이 좋습니다. 거의 발생하지 않으며 불행하게도 발생할 경우에는 부하 테스트를 통해 누수가 발생하는 코드를 찾아 문제를 해결할 수 있습니다. 심지어 개발자가 누수 지점을 찾지 못해도 webman의 내장 모니터 서비스가 적시에 안전하게 누수가 발생한 프로세스를 다시 시작하여 메모리를 해제합니다.

메모리 누수를 가능한한 피하고 싶다면 다음을 참고하세요.
1. `global`, `static` 키워드 배열을 사용하지 않는 것이 좋으며, 사용해야 한다면 그것이 무한히 증가하지 않도록 보장해야 합니다.
2. 익숙하지 않은 클래스의 경우, 가능하면 싱글톤을 사용하지 말고 new 키워드로 초기화하세요. 싱글톤이 필요한 경우 해당 클래스에 장수명의 배열 속성이 있는지 확인하세요.
