# Middleware

Middleware is generally used to intercept requests or responses. For example, uniformly verifying user identity before executing the controller, redirecting to the login page if the user is not logged in, adding a specific header to the response, or even collecting statistics on the proportion of requests for a certain URI, and so on.

## Middleware Onion Model

```
                              
            ┌──────────────────────────────────────────────────────┐
            │                     middleware1                      │ 
            │     ┌──────────────────────────────────────────┐     │
            │     │               middleware2                │     │
            │     │     ┌──────────────────────────────┐     │     │
            │     │     │         middleware3          │     │     │        
            │     │     │     ┌──────────────────┐     │     │     │
            │     │     │     │                  │     │     │     │
 　── Request ───────────────────> Controller ─ Response ───────────────────────────> Client
            │     │     │     │                  │     │     │     │
            │     │     │     └──────────────────┘     │     │     │
            │     │     │                              │     │     │
            │     │     └──────────────────────────────┘     │     │
            │     │                                          │     │
            │     └──────────────────────────────────────────┘     │
            │                                                      │
            └──────────────────────────────────────────────────────┘
```
The middleware and the controller form a classic onion model, where the middleware layers are akin to the layers of an onion, and the controller forms the onion core. As shown in the diagram, the request passes through middleware 1, 2, 3 to reach the controller like an arrow, and the controller returns a response which then passes back through the middleware layers in the order of 3, 2, 1 before being returned to the client. This means that within each middleware, we can both access the request and obtain the response.

## Request Interception

Sometimes we do not want a certain request to reach the controller layer. For example, if in an authentication middleware we find that the current user is not logged in, we can directly intercept the request and return a login response. The process would look something like this:

```
                              
            ┌───────────────────────────────────────────────────────────┐
            │                     middleware1                           │ 
            │     ┌───────────────────────────────────────────────┐     │
            │     │               Authentication Middleware       │     │
            │     │          ┌──────────────────────────────┐     │     │
            │     │          │         middleware3          │     │     │
            │     │          │     ┌──────────────────┐     │     │     │
            │     │          │     │                  │     │     │     │
   ── Request ───────────┐   │     │    Controller    │     │     │     │
            │     │ Response │     │                  │     │     │     │
   <─────────────────────┘   │     └──────────────────┘     │     │     │
            │     │          │                              │     │     │
            │     │          └──────────────────────────────┘     │     │
            │     │                                               │     │
            │     └───────────────────────────────────────────────┘     │
            │                                                           │
            └───────────────────────────────────────────────────────────┘
```

As shown above, the request reaches the authentication middleware, generates a login response, then passes back through middleware 1 before being returned to the browser.

## Middleware Interface

Middleware must implement the `Webman\MiddlewareInterface` interface.

```php
interface MiddlewareInterface
{
    /**
     * Process an incoming server request.
     *
     * Processes an incoming server request in order to produce a response.
     * If unable to produce the response itself, it may delegate to the provided
     * request handler to do so.
     */
    public function process(Request $request, callable $handler): Response;
}
```

This means that the `process` method must be implemented, and it must return a `support\Response` object. By default, this object is generated by `$handler($request)` (request continues to pass through the onion core), but it can also be a response generated by helper functions such as `response()`, `json()`, `xml()`, or `redirect()` (request stops passing through the onion core).

## Accessing Request and Response in Middleware

In the middleware, we can access the request and obtain response after the controller has been executed. Therefore, the middleware can be divided into three parts internally:

1. The request passage phase, which is the phase before request processing.
2. The controller handles the request phase, which is the request processing phase.
3. The response passage phase, which is the phase after request processing.

The manifestation of these three phases in the middleware is as follows:
```php
<?php
namespace app\middleware;

use Webman\MiddlewareInterface;
use Webman\Http\Response;
use Webman\Http\Request;

class Test implements MiddlewareInterface
{
    public function process(Request $request, callable $handler) : Response
    {
        echo 'This is the request passage phase, before request processing';
        
        $response = $handler($request); // Continues to pass through the onion core until the controller generates a response.
        
        echo 'This is the response passage phase, after request processing';
        
        return $response;
    }
}
```

## Example: Authentication Middleware

Create a file `app/middleware/AuthCheckTest.php` (create the directory if it doesn't exist) as follows:
```php
<?php
namespace app\middleware;

use ReflectionClass;
use Webman\MiddlewareInterface;
use Webman\Http\Response;
use Webman\Http\Request;

class AuthCheckTest implements MiddlewareInterface
{
    public function process(Request $request, callable $handler) : Response
    {
        if (session('user')) {
            // The user is already logged in, request continues to pass through the onion core
            return $handler($request);
        }

        $controller = new ReflectionClass($request->controller);
        $noNeedLogin = $controller->getDefaultProperties()['noNeedLogin'] ?? [];

        if (!in_array($request->action, $noNeedLogin)) {
            // Intercept the request and return a redirect response; request stops passing through the onion core
            return redirect('/user/login');
        }

        // The action does not require login, request continues to pass through the onion core
        return $handler($request);
    }
}
```

Create a controller `app/controller/UserController.php` as follows:
```php
<?php
namespace app\controller;
use support\Request;

class UserController
{
    protected $noNeedLogin = ['login'];

    public function login(Request $request)
    {
        $request->session()->set('user', ['id' => 10, 'name' => 'webman']);
        return json(['code' => 0, 'msg' => 'login ok']);
    }

    public function info()
    {
        return json(['code' => 0, 'msg' => 'ok', 'data' => session('user')]);
    }
}
```
> **Note:**
> `$noNeedLogin` records the methods of the current controller that can be accessed without logging in.

Add the global middleware in `config/middleware.php` as follows:
```php
return [
    // Global middleware
    '' => [
        // ... other middleware is omitted here
        app\middleware\AuthCheckTest::class,
    ]
];
```

With the authentication middleware, we can focus on writing business logic in the controller without worrying about whether the user is logged in.

## Example: Cross-origin Request Middleware
Create a file `app/middleware/AccessControlTest.php` (create the directory if it doesn't exist) as follows:
```php
<?php
namespace app\middleware;

use Webman\MiddlewareInterface;
use Webman\Http\Response;
use Webman\Http\Request;

class AccessControlTest implements MiddlewareInterface
{
    public function process(Request $request, callable $handler) : Response
    {
        $response = $request->method() == 'OPTIONS' ? response('') : $handler($request);
        
        $response->withHeaders([
            'Access-Control-Allow-Credentials' => 'true',
            'Access-Control-Allow-Origin' => $request->header('origin', '*'),
            'Access-Control-Allow-Methods' => $request->header('access-control-request-method', '*'),
            'Access-Control-Allow-Headers' => $request->header('access-control-request-headers', '*'),
        ]);
        
        return $response;
    }
}
```

Add the middleware in `config/middleware.php` as follows:
```php
return [
    // Global middleware
    '' => [
        // ... other middleware is omitted here
        app\middleware\AccessControlTest::class,
    ]
];
```
> **Note:**
> If the ajax request has custom headers, it is necessary to include the custom header in the `Access-Control-Allow-Headers` field in the middleware to avoid the `Request header field XXXX is not allowed by Access-Control-Allow-Headers in preflight response.` error.

## Conclusion

- Middleware is divided into global middleware, application-specific middleware (only effective in multi-application mode, see [multiapp.md](multiapp.md)), and route middleware.
- Currently does not support middleware in individual controllers, but similar controller middleware functionality can be implemented in middleware by judging `$request->controller`.
- The middleware configuration file is located in `config/middleware.php`.
- Global middleware configurations are under the key `''`.
- Application-specific middleware configurations are under the specific application names, for example:
```php
return [
    // Global middleware
    '' => [
        app\middleware\AuthCheckTest::class,
        app\middleware\AccessControlTest::class,
    ],
    // Application-specific middleware (only effective in multi-application mode)
    'api' => [
        app\middleware\ApiOnly::class,
    ]
];
```

## Route Middleware

Route middleware can be set for a single route or a group of routes. For example, add the following configuration to the `config/route.php` file:
```php
<?php
use support\Request;
use Webman\Route;

Route::any('/admin', [app\admin\controller\IndexController::class, 'index'])->middleware([
    app\middleware\MiddlewareA::class,
    app\middleware\MiddlewareB::class,
]);

Route::group('/blog', function () {
   Route::any('/create', function () {return response('create');});
   Route::any('/edit', function () {return response('edit');});
   Route::any('/view/{id}', function ($r, $id) {response("view $id");});
})->middleware([
    app\middleware\MiddlewareA::class,
    app\middleware\MiddlewareB::class,
]);
```

## Passing Parameters to Middleware Constructors

This feature requires `webman-framework >= 1.4.8`. After version 1.4.8, the configuration file supports direct instantiation of middleware or anonymous functions, making it convenient to pass parameters to middleware through their constructors. For example, in the `config/middleware.php` file, you can configure as follows:
```
return [
    // Global middleware
    '' => [
        new app\middleware\AuthCheckTest($param1, $param2, ...),
        function(){
            return new app\middleware\AccessControlTest($param1, $param2, ...);
        },
    ],
    // Application-specific middleware (only effective in multi-application mode)
    'api' => [
        app\middleware\ApiOnly::class,
    ]
];
```
Similarly, route middleware can also pass parameters through their constructors. For example, in the `config/route.php` file, you can configure as follows:
```
Route::any('/admin', [app\admin\controller\IndexController::class, 'index'])->middleware([
    new app\middleware\MiddlewareA($param1, $param2, ...),
    function(){
        return new app\middleware\MiddlewareB($param1, $param2, ...);
    },
]);
```

## Middleware Execution Order
- The middleware execution order is `global middleware` -> `application-specific middleware` -> `route middleware`.
- When there are multiple global middleware, they are executed in the order they are configured (the same applies to application-specific and route middleware).
- The 404 request does not trigger any middleware, including global middleware.

## Passing Parameters to Middleware from Route (route->setParams)

**Route Configuration `config/route.php`**
```php
<?php
use support\Request;
use Webman\Route;

Route::any('/test', [app\controller\IndexController::class, 'index'])->setParams(['some_key' =>'some value']);
```

**Middleware (Assuming it's a global middleware)**
```php
<?php
namespace app\middleware;

use Webman\MiddlewareInterface;
use Webman\Http\Response;
use Webman\Http\Request;

class Hello implements MiddlewareInterface
{
    public function process(Request $request, callable $handler) : Response
    {
        // Default route $request->route is null, so it needs to be checked if $request->route is empty
        if ($route = $request->route) {
            $value = $route->param('some_key');
            var_export($value);
        }
        return $handler($request);
    }
}
```

## Passing Parameters from Middleware to Controller

Sometimes, the controller needs to use data generated in the middleware. In such cases, we can pass parameters to the controller by adding properties to the `$request` object. For example:

**Middleware**
```php
<?php
namespace app\middleware;

use Webman\MiddlewareInterface;
use Webman\Http\Response;
use Webman\Http\Request;

class Hello implements MiddlewareInterface
{
    public function process(Request $request, callable $handler) : Response
    {
        $request->data = 'some value';
        return $handler($request);
    }
}
```

**Controller:**
```php
<?php
namespace app\controller;

use support\Request;

class FooController
{
    public function index(Request $request)
    {
        return response($request->data);
    }
}
```

## Middleware Getting Current Request Route Information

This feature requires `webman-framework >= 1.3.2`. We can use `$request->route` to get the route object, and then call the corresponding method to get the information.

**Route Configuration**
```php
<?php
use support\Request;
use Webman\Route;

Route::any('/user/{uid}', [app\controller\UserController::class, 'view']);
```

**Middleware**
```php
<?php
namespace app\middleware;

use Webman\MiddlewareInterface;
use Webman\Http\Response;
use Webman\Http\Request;

class Hello implements MiddlewareInterface
{
    public function process(Request $request, callable $handler) : Response
    {
        $route = $request->route;
        // If the request does not match any routes (except the default route), $request->route will be null
        // Assuming the browser accesses the address /user/111, the following information will be printed
        if ($route) {
            var_export($route->getPath());       // /user/{uid}
            var_export($route->getMethods());    // ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS']
            var_export($route->getName());       // user_view
            var_export($route->getMiddleware()); // []
            var_export($route->getCallback());   // ['app\\controller\\UserController', 'view']
            var_export($route->param());         // ['uid'=>111]
            var_export($route->param('uid'));    // 111 
        }
        return $handler($request);
    }
}
```

> **Note:**
> The `$route->param()` method requires `webman-framework >= 1.3.16`

## Middleware Getting Exception

This feature requires `webman-framework >= 1.3.15`. We can use `$response->exception()` to get the exception when an error occurs in the middleware.

**Route Configuration**
```php
<?php
use support\Request;
use Webman\Route;

Route::any('/user/{uid}', function (Request $request, $uid) {
    throw new \Exception('exception test');
});
```

**Middleware:**
```php
<?php
namespace app\middleware;

use Webman\MiddlewareInterface;
use Webman\Http\Response;
use Webman\Http\Request;

class Hello implements MiddlewareInterface
{
    public function process(Request $request, callable $handler) : Response
    {
        $response = $handler($request);
        $exception = $response->exception();
        if ($exception) {
            echo $exception->getMessage();
        }
        return $response;
    }
}
```

## Super Global Middleware

This feature requires `webman-framework >= 1.5.16`. The super global middleware affects not only the main project but also all [application plugins](app/app.md). If you want to add a middleware that affects all the plugins, you can use the super global middleware.

Configure as follows in the `config/middleware.php` file:
```php
return [
    '@' => [ // Add global middleware to the main project and all plugins
        app\middleware\MiddlewareGlobl::class,
    ], 
    '' => [], // Add global middleware only to the main project
];
```

> **Note:**
> The `@` super global middleware can be configured not only in the main project but also in a specific plugin. For example, if the super global middleware is configured in the `plugin/ai/config/middleware.php`, it will also affect the main project and all plugins.

## Adding Middleware to a Plugin

This feature requires `webman-framework >= 1.5.16`. If you want to add middleware to a specific [application plugin](app/app.md) without changing the plugin's code (as it will be overridden during an upgrade), you can configure it in the main project to add middleware to the plugin.

Configure as follows in the `config/middleware.php` file:
```php
return [
    'plugin.ai' => [], // Add middleware to the ai plugin
    'plugin.ai.admin' => [], // Add middleware to the admin module of the ai plugin
];
```

> **Note:**
> Similarly, you can also add a similar configuration to another plugin to affect other plugins. For example, adding the same configuration in `plugin/foo/config/middleware.php` will affect the ai plugin.
