# メモリーリークについて
webmanは常駐メモリーのフレームワークであるため、メモリーリークの状況には注意が必要です。ただし、開発者は余分なメモリ管理の操作を行う必要はないため、心配する必要はありません。

> **ヒント**
> webmanには、全てのプロセスのメモリ使用状況を監視するmonitorプロセスが組み込まれており、プロセスがphp.iniで設定された`memory_limit`の値に近づくと、自動的に対応するプロセスを安全に再起動してメモリを解放します。この間、ビジネスには影響がありません。

## メモリーリークの定義
リクエストの増加に伴い、webmanの使用するメモリーが**無限に増加**し、何百MB、またはそれ以上に達する場合、これをメモリーリークと呼びます。メモリーサイズが増加したが後続で増加しなくなった場合は、メモリーリークではありません。

通常、プロセスが数十MBのメモリを占有するのは正常な状況であり、プロセスが超大規模なリクエストを処理したり、大量の接続を維持する場合、単一プロセスのメモリ占有量は100MBを超えることがよくあります。このようなメモリ使用後、phpはすべてを操作システムに戻さないかもしれません。再利用のために残し、そのためには特定の大きなリクエストを処理した後、メモリ占有量が増加し、メモリが解放されないという正常な現象が発生する場合があります。(gc_mem_caches()メソッドを呼び出すことで一部の空きメモリを解放することができます)


## メモリーリークの発生原因
**メモリーリークは、以下の2つの条件を満たす必要があります：**
1. **長寿命の**配列が存在すること（通常の配列では問題ありません）
2. かつ、この**長寿命の**配列が無限に拡大すること（ビジネスがデータを無制限に挿入し、データをクリアしないこと）

これらの条件が**同時に**満たされる場合にのみメモリーリークが発生します。それ以外の場合、または1つの条件のみを満たす場合はメモリーリークではありません。


## 長寿命の配列

webmanでの長寿命の配列には次のようなものがあります：
1. staticキーワードで定義された配列
2. シングルトンの配列プロパティ
3. globalキーワードで定義された配列


> **注意**
> webmanでは長寿命のデータを使用することができますが、そのデータ内の要素が有限であることを確認する必要があります。要素の数が無限に拡大することは避ける必要があります。


以下にそれぞれの例を示します

#### 無限膨張するstatic配列
```php
class Foo
{
    public static $data = [];
    public function index(Request $request)
    {
        self::$data[] = time();
        return response('hello');
    }
}
```

リクエストに応じて増加し続ける`$data`配列はstaticキーワードで定義された長寿命の配列であり、この配列が不断に膨張することにより、メモリーリークが発生します。

#### 無限膨張するシングルトン配列プロパティ
```php
class Cache
{
    protected static $instance;
    public $data = [];
    
    public function instance()
    {
        if (!self::$instance) {
            self::$instance = new self;
        }
        return self::$instance;
    }
    
    public function set($key, $value)
    {
        $this->data[$key] = $value;
    }
}
```

呼び出しコード
```php
class Foo
{
    public function index(Request $request)
    {
        Cache::instance()->set(time(), time());
        return response('hello');
    }
}
```

`Cache::instance()`はCacheのシングルトンを返し、これは長寿命のクラスインスタンスであり、その`$data`プロパティはstaticキーワードを使用していませんが、クラス自体が長寿命であるため、`$data`も長寿命の配列となります。異なるキーのデータを不断に`$data`配列に追加することで、プログラムのメモリ占有量も増加し続け、メモリーリークが発生します。

> **注意**
> Cache::instance()->set(key, value)で追加されるkeyが有限の場合、メモリーリークは発生しません。なぜなら、`$data`配列が無限膨張しないからです。

#### 無限膨張するglobal配列
```php
class Index
{
    public function index(Request $request)
    {
        global $data;
        $data[] = time();
        return response($foo->sayHello());
    }
}
```
関数またはメソッドの実行後にglobalキーワードで定義された配列は回収されないため、長寿命の配列となります。上記のコードは要求に応じて増加し続けるため、メモリーリークが発生します。同様に、関数またはメソッド内でstaticキーワードで定義された配列も長寿命の配列であり、配列が無限に膨張した場合にもメモリーリークが発生します。例：
```php
class Index
{
    public function index(Request $request)
    {
        static $data = [];
        $data[] = time();
        return response($foo->sayHello());
    }
}
```

## アドバイス
メモリーリークに特別な注意を払う必要はありませんが、ほとんど発生しません。もし不幸にも発生した場合は、負荷テストでリークを引き起こすコードを特定し、問題を特定できます。開発者がリークポイントを見つけることができない場合でも、webmanにはメモリーリークが発生したプロセスを適時に安全に再起動し、メモリを解放するmonitorサービスが組み込まれています。

もしできるだけメモリーリークを避けたい場合は、以下のアドバイスに従うことができます。
1. `global`、`static`キーワードで配列を使用しないようにする。使用する場合は、それが無限に膨張しないようにする。
2. 不慣れなクラスを使用しないようにし、クラスの初期化に`new`キーワードを使用する。シングルトンが必要な場合、そのクラスに無限膨張する配列プロパティがあるかどうかを確認する。
