# webmanの性能

### 伝統的なフレームワークのリクエスト処理フロー

1. nginx/apacheがリクエストを受け取る
2. nginx/apacheがリクエストをphp-fpmに渡す
3. php-fpmが環境の初期化を行い、変数リストの作成などを行う
4. php-fpmが各拡張/モジュールのRINITを呼び出す
5. php-fpmがphpファイルをディスクから読み込む（opcacheを使用することで回避可能）
6. php-fpmがレキシカル解析、構文解析、opcodeにコンパイルする（opcacheを使用することで回避可能）
7. php-fpmがopcodeを実行する、8.9.10.11を含む
8. フレームワークの初期化、コンテナ、コントローラー、ルート、ミドルウェアなどのインスタンス化などを含む
9. フレームワークがデータベースに接続し、権限認証を行い、redisに接続する
10. フレームワークがビジネスロジックを実行する
11. フレームワークがデータベース、redis接続を閉じる
12. php-fpmがリソースを解放し、すべてのクラス定義とインスタンスを破棄し、シンボルテーブルを破棄する
13. php-fpmが各拡張/モジュールのRSHUTDOWNメソッドを順番に呼び出す
14. php-fpmが結果をnginx/apacheに転送する
15. nginx/apacheが結果をクライアントに返す

### webmanのリクエスト処理フロー

1. フレームワークがリクエストを受け取る
2. フレームワークがビジネスロジックを実行する
3. フレームワークが結果をクライアントに返す

はい、nginxのリバースプロキシがない場合、フレームワークにはこの3ステップしかありません。このことから、これはすでにphpフレームワークの究極と言えるでしょう。これにより、webmanのパフォーマンスは従来のフレームワークの数倍、さらには数十倍にもなります。

詳細は[負荷テスト](benchmarks.md)を参照してください。
