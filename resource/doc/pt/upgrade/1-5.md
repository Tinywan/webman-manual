# Guia de Atualização 1.5

**Faça backup antes de atualizar, execute o comando de atualização a seguir**
`composer require workerman/webman-framework ^1.5 -W && composer require webman/console ^1.2.12 && php webman install`

# Características e Mudanças

Suporte para workerman v5 [fibras](https://www.workerman.net/doc/workerman/fiber.html)

> **Dica**
> workerman v5 requer PHP>=8.1
> Comando de atualização workerman `composer require workerman/workerman ^5.0.0 -W`
> As fibras requerem instalação `composer require revolt/event-loop ^1.0.0`

# Exemplos
### Resposta atrasada

```php
<?php

namespace app\controller;

use support\Request;
use Workerman\Timer;

class TestController
{
    public function index(Request $request)
    {
        // Dorme por 1,5 segundos
        Timer::sleep(1.5);
        return $request->getRemoteIp();
    }
}
```
`Timer::sleep()` é semelhante à função `sleep()` padrão do PHP, a diferença é que `Timer::sleep()` não bloqueará o processo.


### Enviar solicitação HTTP

> **Nota**
> Necessita instalar `composer require workerman/http-client ^2.0.0`

```php
<?php

namespace app\controller;

use support\Request;
use Workerman\Http\Client;

class TestController
{
    public function index(Request $request)
    {
        static $client;
        $client = $client ?: new Client();
        $response = $client->get('http://example.com'); // Envio assíncrono de solicitação de forma síncrona
        return $response->getBody()->getContents();
    }
}
```
Da mesma forma, a solicitação `$client->get()` é não bloqueante, e pode ser utilizado para processar solicitações HTTP de forma não bloqueante no webman, melhorando o desempenho.

Para mais informações, consulte [workerman/http-client](https://www.workerman.net/doc/workerman/components/workerman-http-client.html)

### Adição da classe support\Context

A classe support\Context é usada para armazenar dados relacionados à solicitação. Quando a solicitação é concluída, os dados de contexto correspondentes serão excluídos automaticamente. Isso significa que o ciclo de vida dos dados de contexto segue o ciclo de vida da solicitação.

### Poluição de variáveis globais

Ambiente de fibra proíbe o armazenamento de informações de estado **relacionadas à solicitação** em variáveis globais ou estáticas, pois isso pode resultar em poluição de variáveis globais, por exemplo

```php
<?php

namespace app\controller;

use support\Request;
use Workerman\Timer;

class TestController
{
    protected static $name = '';

    public function index(Request $request)
    {
        static::$name = $request->get('name');
        Timer::sleep(5);
        return static::$name;
    }
}
```

Definindo o número de processos como 1, quando fazemos duas solicitações consecutivas  
http://127.0.0.1:8787/test?name=lilei  
http://127.0.0.1:8787/test?name=hanmeimei  
Esperamos que os resultados das duas solicitações sejam respectivamente `lilei` e `hanmeimei`, mas na realidade ambos retornam `hanmeimei`.
Isso ocorre porque a segunda solicitação sobrescreve a variável estática `$name`, e quando a primeira solicitação conclui a espera, ela retorna a variável estática `$name` que agora é `hanmeimei`.

**O método correto é usar o armazenamento de estado da solicitação em um contexto**
```php
<?php

namespace app\controller;

use support\Request;
use support\Context;
use Workerman\Timer;

class TestController
{
    public function index(Request $request)
    {
        Context::set('name', $request->get('name'));
        Timer::sleep(5);
        return Context::get('name');
    }
}
```

**Variáveis locais não causam poluição de dados**
```php
<?php

namespace app\controller;

use support\Request;
use support\Context;
use Workerman\Timer;

class TestController
{
    public function index(Request $request)
    {
        $name = $request->get('name');
        Timer::sleep(5);
        return $name;
    }
}
```
Por ser uma variável local, as fibras não podem acessar variáveis locais umas das outras, portanto, é seguro em termos de fibras.

# Sobre Fibras

Fibra não é uma solução universal, sua introdução significa que é necessário estar atento à poluição de variáveis globais/estáticas e à configuração do contexto. Além disso, depurar bugs em um ambiente de fibra é mais complexo do que em programação bloqueante.

Na verdade, a programação bloqueante do webman já é rápida o suficiente, de acordo com os dados de benchmarking dos últimos três anos em [techempower.com](https://www.techempower.com/benchmarks/#section=data-r21&l=zijnjz-6bj&test=db&f=1ekg-cbcw-2t4w-27wr68-pc0-iv9slc-0-1ekgw-39g-kxs00-o0zk-4fu13d-2x8do8-2), a programação bloqueante do webman com operações de banco de dados é quase 1 vez mais rápida do que a estrutura web em Go, como gin e echo, e quase 40 vezes mais rápida do que a estrutura tradicional laravel.
![](../../assets/img/benchemarks-go-sw.png?)

Quando o banco de dados, redis, etc. estão na rede interna, a programação bloqueante com múltiplos processos muitas vezes tem um desempenho melhor do que as fibras. Isso se deve ao fato de que, quando o banco de dados, redis, etc. são rápidos o suficiente, o custo de criação, programação e destruição de fibras pode ser maior do que o custo de troca de processos, portanto, a introdução de fibras pode não aumentar significativamente o desempenho.

# Quando usar Fibras
Quando há solicitações lentas no aplicativo, como a necessidade de acessar um serviço de terceiros, pode-se usar o [workerman/http-client](https://www.workerman.net/doc/workerman/components/workerman-http-client.html) para enviar chamadas HTTP assíncronas de forma síncrona como fibras, aumentando a capacidade de concorrência do aplicativo.
