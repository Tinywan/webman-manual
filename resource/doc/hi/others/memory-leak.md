# मेमोरी लीक के बारे में
वेबमेन एक रिसाइडेंट मेमोरी फ्रेमवर्क है, इसलिए हमें मेमोरी लीक की स्थिति पर ध्यान देना चाहिए। हालांकि डेवलपर को चिंता करने की आवश्यकता नहीं है, क्योंकि मेमोरी लीक बहुत ही अत्यंत परिस्थितियों में होती है और इसे आसानी से टाला जा सकता है। वेबमेन विकास और पारंपरिक फ़्रेमवर्क विकास अनुभव में बहुत ही समान है, जिससे कि मेमोरी प्रबंधन के लिए अतिरिक्त कार्यों की आवश्यकता नहीं होती है।

> **सुझाव**
> वेबमेन स्वयं के मॉनिटर प्रोसेस के द्वारा सभी प्रक्रियाओं के मेमोरी उपयोग की स्थिति का पर्यवेक्षण करेगा। यदि प्रक्रिया इस्तेमाल की जा रही से फिर से php.ini में `memory_limit` के निर्धारित मान तक पहुंचने वाला है, तो स्वचालित रूप से संबंधित प्रक्रिया को सुरक्षित रीस्टार्ट कर दिया जाएगा, जिससे मेमोरी जारी करने का प्रभाव होगा, इस दौरान व्यापार पर कोई प्रभाव नहीं पड़ेगा।

## मेमोरी लीक की परिभाषा
निरंतर अनुरोधों के साथ, वेबमेन द्वारा उपयोग की जाने वाली मेमोरी भी **असीमित रूप** में बढ़ती है (ध्यान दें कि यह **असीमित रूप** में बढ़ जाती है), जो कुछ सैंड्स में या उससे अधिक हो सकती है, यह एक मेमोरी लीक है। अगर मेमोरी का वृद्धि होता है, लेकिन बाद में नहीं बढ़ता है, तो इसे मेमोरी लीक नहीं कहा जाता है।

सामान्यत: प्रक्रिया के कुछ मेगा-बाइट मेमोरी का उपयोग करना बहुत ही सामान्य होता है। जब प्रक्रिया बड़ा अनुरोध या बहुत सारे कनेक्शन को संभालने की कोशिश करती है, तो एक एकल प्रक्रिया मेमोरी का उपयोग सैंड्स में तक पहुंच सकती है। यह मेमोरी का उपयोग करने के बाद php शायद सभी लिए ऑपरेटिंग सिस्टम को पूरी तरह से लौटा नहीं देता। बल्कि उसे पुन: उपयोग के लिए छोड़ देता है, इसलिए कुछ बड़े अनुरोध को संभालने के बाद मेमोरी का उपयोग वृद्धि होता है और मेमोरी नहीं रिलीज़ होती है, यह सामान्य घटना है। (gc_mem_caches() विधि को कॉल करके कुछ कर्शित मेमोरी रिलीज़ किया जा सकता है)

## मेमोरी लीक कैसे होता है
**मेमोरी लीक होने के लिए निम्नलिखित दो शर्तें पूर्ण होनी चाहिए:**
1. एक **लंबी जीवनचक्रीय** मानवी(ध्यान दें कि यह लंबी जीवनचक्रीय प्रकार की एरे, शांतजीवाणी एरे नहीं है)
2. और इस **लंबी जीवनचक्रीय** एरे में असीमित संख्या में वृद्धि होगी (व्यवसाय असीमित रूप में उसे डेटा डालता है, डेटा को स्वयं नहीं साफ़ करता है)

यदि 1 और 2 शर्तें **साथ में पूर्ण होती हैं** (ध्यान दें कि साथ में पूर्ण होती हैं), तो मेमोरी लीक होगी। उल्टा इस शर्त को पूरा न करते हैं या केवल एक शर्त को पूरा करते हैं तो यह मेमोरी लीक नहीं होती है।

## लंबी जीवनचक्रीय एरे
वेबमेन में लंबी जीवनचक्रीय एरे निम्नलिखित शामिल होती हैं:
1. स्टैटिक कीवर्ड से बनाई गई एरे
2. एकल आवस्य प्रतिष्ठित आवो कीवर्ड से बनाई गई एरे
3. ग्लोबल कीवर्ड से बनाई गई एरे

> **ध्यान दें**
> वेबमेन में लंबी जीवनचक्रीय डेटा का उपयोग करने की अनुमति है, लेकिन सुनिश्चित करना चाहिए कि डेटा में डेटा सीमित होता है, ताकि तत्वों की संख्या असीमित रूप से बढ़ी न करे।

निम्नलिखित प्रत्येक उदाहरण को स्पष्ट करते हैं

#### असीमित वृद्धि करने वाला स्टैटिक एरे
```php
class Foo
{
    public static $data = [];
    public function index(Request $request)
    {
        self::$data[] = time();
        return response('hello');
    }
}
```

इसमें `static` कीवर्ड से प्रारूपित `$data` एरे एक लंबी जीवनचक्रीय एरे है, और उदाहरण में `$data` एरे अनुरोध के साथ बढ़ता है, जिससे मेमोरी लीक होती है।

#### असीमित वृद्धि करनेवा  एकल आवस्य एरे संपत्ति
```php
class Cache
{
    protected static $instance;
    public $data = [];
    
    public function instance()
    {
        if (!self::$instance) {
            self::$instance = new self;
        }
        return self::$instance;
    }
    
    public function set($key, $value)
    {
        $this->data[$key] = $value;
    }
}
```

कॉल कोड
```php
class Foo
{
    public function index(Request $request)
    {
        Cache::instance()->set(time(), time());
        return response('hello');
    }
}
```

`Cache::instance()` एक कैश एकल प्रतिष्ठित वापस करता है, यह एक लंबी जीवनचक्रीय क्लास उदाहरण होता है, हालांकि इसका `$data` संपत्ति चाहे कि वह `static` कीवर्ड का उपयोग करती है या नहीं हो, लेकिन क्योंकि यह एक लंबी जीवनचक्रीय है, इसलिए `$data` भी लंबी जीवनचक्रीय एरे होती है। अनंतर अलग अलग की तिथि की संपत्ति में जाते हुए इसे उपयोग करते हुए करने के कारण, प्रोग्राम की मेमोरी भी बढ़ती है, जिससे मेमोरी लीक होती है।

> **सुझाव**
> यदि Cache::instance()->set(कुंजी, मान) द्वारा जोड़ी गई कुंजी संख्या सीमित होती है, तो यह मेमोरी लीक नहीं होगी, क्योंकि `$data` एरे अनंतर बढ़ावा नहीं करे गा।

#### असीमित वृद्धि करने वाले ग्लोबल एरे
```php
class Index
{
    public function index(Request $request)
    {
        global $data;
        $data[] = time();
        return response($foo->sayHello());
    }
}
```
फ़ंक्शन या फ़ंक्शन में स्थानीय रूप से डिफाइन की गयी ग्लोबल कीवर्ड की विशेष नहीं होती है, इसलिए यह लंबी जीवनचक्रीय एरे होती है, उपरोक्त कोडनी जो बढ़ती है। और इसके अनुसार मेमोरी लीक हो सकता है। उसी प्रकार फ़ंक्शन या विधि में `static` कीवर्ड से डिफाइन की गई एरे भी लंबी जीवनचक्रीय एरे होते हैं, यदि एरे असीमित रूप में वृद्धि होती है, तो यह भी मेमोरी लीक का कारण हो सकता है, उदाहरण के लिए:
```php
class Index
{
    public function index(Request $request)
    {
        static $data = [];
        $data[] = time();
        return response($foo->sayHello());
    }
}
```

## सुझाव
संभावना नहीं है कि डेवलपर मेमोरी लीक पर विचार करे, क्योंकि यह बहुत ही कम होती है, यदि खुशकिस्मती से यह होता है, तो हम दबाव प्रदर्शनी के आधार पर खोज सकते ह
