# व्यावसायिक प्रारंभीकरण

कभी-कभी हमें प्रक्रिया प्रारंभ होने के बाद कुछ व्यावसायिक प्रारंभ करने की आवश्यकता होती है, जो प्रक्रिया जीवनकाल में केवल एक बार ही काम करता है, जैसे प्रक्रिया शुरू होने के बाद एक टाइमर सेट करना, या डेटाबेस कनेक्शन की प्रारंभिकीकरण आदि। नीचे, हम इस पर चर्चा करेंगे।

## सिद्धांत
**[प्रक्रिया प्रवाह](process.md)** के अनुसार, वेबमैन प्रक्रिया के शुरू होने के बाद `config/bootstrap.php` (इसमें `config/plugin/*/*/bootstrap.php` भी शामिल है) में सेट किए गए क्लासों को लोड करता है और क्लास के `start` मेथड को चलाता है। हम `start` मेथड में व्यावसायिक कोड जोड़ सकते हैं, जिससे प्रक्रिया शुरू होने के बाद व्यावसायिक प्रारंभ ऑपरेशन पूरा हो जाता है।

## प्रक्रिया
मानें कि हमें एक टाइमर बनाना है, जिसका उपयोग प्रति नियमित अंतराल पर वर्तमान प्रोसेस के मेमोरी उपयोग की रिपोर्ट करने के लिए करना है, तो इस क्लास का नाम `MemReport` होगा।

#### आदेश चलाएं

आदेश चलाकर `php webman make:bootstrap MemReport` कमांड को चलाकर प्रारंभीकरण फाइल `app/bootstrap/MemReport.php` उत्पन्न करें।

> **सुझाव**
> यदि आपके पास `webman/console` इंस्टॉल नहीं है, तो `composer require webman/console` कमांड चलाकर इंस्टॉल करें।

#### प्रारंभीकरण फाइल संपादित करें
`app/bootstrap/MemReport.php` को संपादित करें, जैसा कि निम्नलिखित उदाहरण में है:
```php
<?php

namespace app\bootstrap;

use Webman\Bootstrap;

class MemReport implements Bootstrap
{
    public static function start($worker)
    {
        // क्या यह कमांड लाइन माध्यम है ?
        $is_console = !$worker;
        if ($is_console) {
            // यदि आप चाहते हैं कि इस तरह से प्रारंभ न हो, तो यहां सीधे रिटर्न करें
            return;
        }
        
        // हर 10 सेकंड में एक बार चलाएं
        \Workerman\Timer::add(10, function () {
            // प्रदर्शन के लिए, यहां रिपोर्ट प्रक्रिया के बजाय आउटपुट का उपयोग करना है
            echo memory_get_usage() . "\n";
        });
        
    }

}
```

> **सुझाव**
> कमांड लाइन का उपयोग करते समय, फ़्रेमवर्क `config/bootstrap.php` में सेट की गई `start` मेथड को भी निष्पादित करेगा, हम `$worker` के `null` होने के आधार पर यह निर्णय ले सकते हैं कि क्या यह कमांड लाइन माध्यम है और क्या व्यावसायिक प्रारंभीकरण कोड को निष्पादित करना है।

#### प्रक्रिया के साथ स्थापित करें
`config/bootstrap.php` खोलकर `MemReport` क्लास को प्रारंभिकीकरण आइटम में जोड़ें।
```php
return [
    // ...यहाँ अन्य कॉन्फ़िगरेशन छोड़ दी गई है...
    
    app\bootstrap\MemReport::class,
];
```

इस तरह, हमने एक व्यावसायिक प्रारंभीकरण प्रक्रिया पूरी कर दी है।

## अतिरिक्त विवरण
[कस्टम प्रक्रिया](../process.md) प्रारंभ होने के बाद भी `config/bootstrap.php` में सेट की गई `start` मेथड को निष्पादित करेगा, हम `$worker->name` के माध्यम से जांच सकते हैं कि वर्तमान प्रक्रिया कौन सी है, और फिर इस प्रक्रिया में आपके व्यावसायिक प्रारंभीकरण कोड को निष्पादित करने का निर्णय ले सकते हैं, जैसे की हमें मॉनिटर प्रक्रिया को मॉनिटरिंग की आवश्यकता नहीं है, तो `MemReport.php` का विषय लगभग निम्नलिखित हो सकता है:
```php
<?php

namespace app\bootstrap;

use Webman\Bootstrap;

class MemReport implements Bootstrap
{
    public static function start($worker)
    {
        // क्या यह कमांड लाइन माध्यम है ?
        $is_console = !$worker;
        if ($is_console) {
            // यदि आप चाहते हैं कि इस तरह से प्रारंभ न हो, तो यहां सीधे रिटर्न करें
            return;
        }
        
        // मॉनिटर प्रक्रिया को टाइमर नहीं चलाना
        if ($worker->name == 'monitor') {
            return;
        }
        
        // हर 10 सेकंड में एक बार चलाएं
        \Workerman\Timer::add(10, function () {
            // प्रदर्शन के लिए, यहां रिपोर्ट प्रक्रिया के बजाय आउटपुट का उपयोग करना है
            echo memory_get_usage() . "\n";
        });
        
    }

}
```
