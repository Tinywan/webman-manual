# जीवनकाल

## प्रक्रम जीवनकाल
- प्रत्येक प्रक्रियाले लामो जीवनकाल छ
- प्रत्येक प्रक्रिया स्वतन्त्र रूपमा चलिरहेका हुन्छन्, एक अर्काको असर गर्दैनन्
- प्रत्येक प्रक्रियाले आफ्नो जीवनकाल भित्र धेरै अनुरोधहरू सम्बोधित गर्न सक्दछ
- प्रक्रिया 'stop', 'reload', 'restart' आदि आदेश प्राप्त गरेमा बाहिरिन्छ र, यस चक्रको समाप्ति हुनेछ।

> **सुझाव**
> प्रत्येक प्रक्रिया स्वतन्त्र रूपमा असर गर्दछ, जसले यो अर्थ गर्दछ कि प्रत्येक प्रक्रियाले आफ्नो आवश्यकता, चर, तथा वर्ग उदाहरणका रूपमा सञ्चालन गर्दछ, जुनले प्रत्येक प्रक्रियाले आफ्नो डाटाबेसको कनेक्सन, केही एकदमै तर्जुमा नहुने गरेको हुने छ, जसले यसलाई प्रत्येक प्रक्रियाले धेरै पटक सुरू गर्दछ।

## अनुरोध जीवनकाल
- प्रत्येक अनुरोधले `$request` ढाँचाबाट नयाँ वस्तु उत्पन्न गर्दछ
- `$request` ढाँचाले अनुरोध प्रक्रिया पछि मुक्त हुनेछ

## नियंत्रक जीवनकाल
- प्रत्येक नियंत्रक प्रत्येक प्रक्रियामा केवल एक पटक उदाहरणारूपमा निपट्दैन, धेरै प्रक्रियाहरूमा धेरैपटक निपट्दैन (नियंत्रक पुनः उपयोग बन्द गर्दा बाहेक, नियंत्रक जीवनकाल को लागि हेर्नुहोस् [नियंत्रक जीवनकाल](https://www.workerman.net/doc/webman/controller.html#%E0%A4%B6%E0%A4%BE%E0%A4%B0%E0%A4%BE%E0%A4%A4%E0%A5%8D%E0%A4%AE%E0%A4%BE-%E0%A4%B8%E0%A4%B0%E0%A4%B9))) 
- नियंत्रक इन्स्टेन्सले चल्नुअघि वर्तमान प्रक्रियामा बहुपटकका अनुरोध साझा गरिनेछ (नियंत्रक पुनः उपयोग बन्द गर्दा)
- नियंत्रक जीवनकाल प्रक्रिया बाहिरिनेछ (नियंत्रक पुनः उपयोग बन्द गर्दा)

## वस्तु जीवनकालका बारेमा
webman भएको छ पीएचपीमा आधारित, यसका कारण यो पूर्णत: पीएचपीमा संकलनको व्यवस्थापन मान्य गर्दछ। व्यावसायिक तत्वहरूले उत्पन्न गरेको अस्थायी चरको स्वरूपले संकलन गर्दछ, बिना हातले `अन्सेट` गर्न आवस्यक छैन। अथवा कुनै पनिनिक्लिको बंद भएको नै अर्थ गरिन्छ। यस अर्थले कि webman डेभलपमेन्टलाई पारम्परिक ढाँचाबाट व्यवस्थित गर्दछ। उदाहरण स्वरूप, तलको उदाहरणमा `$foo` इन्स्टेन्सले इन्डेक्स विधिसको समापनबाट स्वतः मुक्त हुनेछ:

```php
<?php

namespace app\controller;

use app\service\Foo;
use support\Request;

class IndexController
{
    public function index(Request $request)
    {
        $foo = new Foo(); // यहाँ म स्विकृती छ
        return response($foo->sayHello());
    }
}
```
यदि तपाईं चाहानुहुन्छ विषय समूहले पुनः पुनः चल्छ भने, मैले आवश्यकता प्राप्त नभएको रूपमा वस्तुलाई कायम गर्न रूपरेखामा राख्न सक्छु, त्वरित जीवनकालका वस्तु (जस्तै नियंत्रक) स्वतः हल्न सकिन्छ, अथवा `Container` हर्क्डरको `get` विधिलाई प्रयोग गर्न सकिन्छ, उदाहरणका लागि:

```php
<?php

namespace app\controller;

use app\service\Foo;
use support\Container;
use support\Request;

class IndexController
{
    public function index(Request $request)
    {
        $foo = Container::get(Foo::class);
        return response($foo->sayHello());
    }
}
```

`Container::get()` विधि परिमाणहरू संचालन गर्न र संचालन गर्न नयाँ इन्स्टेन्सलाई मिलाउनका लागि बनाउन्छ।

> **सावधानी**
> `Container::get()` मात्र अभिव्यक्तिहरूमा बिन्दुसमूह बिन्दुसमूहलाई प्रारम्भ गर्न सक्दैन। `Container::make()` जिस्तो, कन्स्ट्रक्टर पारामीटरसहितको इन्स्टेन्सलाई बनाउन सक्छ, तर `Container::get()` बिन्दुसमूहहरूलाई पुनरावाद गरिदैन, अर्थात, त्वरितै आफ्नो पारामीटरको साथै बनाउन्छ।

# मेमोरी लिकका बारेमा
प्राय: सर्वाधिक प्रस्तुतिहरूमा, हाम्रो व्यावसायिक कोडले मेमोरी लिकलाई टुच्छ बनाउने छैन (वास्तवमा प्रयोगकर्ताहरूको नक्सले मेमोरी लिकका कुरा गरेर त्यस्ता बन्दैन), हामी मात्र सावधान भएपछि लामो जीवनकालको एरेली डाटा अनिश्चित रूपमा नबढी जाँच्न सक्दछ। कृपया तल दिइएको कोडलाई हेर्नुहोस्:

```php
<?php
namespace app\controller;

use support\Request;

class FooController
{
    // एरेली गोप्यता वस्त्रहरू
    public $data = [];
    
    public function index(Request $request)
    {
        $this->data[] = time();
        return response('नमस्ते इन्डेक्स');
    }

    public function hello(Request $request)
    {
        return response('नमस्ते webman');
    }
}
```
नियंत्रक चाडै लामो जीवनकालका हुने गरी, त्यस्तै नियंत्रकको `$data` अर्रे पनि लामो जीवनकालका हुनेछ, `foo/index` अनुरोधले नथर्कुल्यी प्रवृद्धिको कारण, `$data` अर्रे तत्त्वहरू बढ्दो छ र मेमोरी लिक हुँदै गरेको हुन्छ।

थप जानकारीका लागि कृपया हेर्नुहोस् [मेमोरी लिक](./memory-leak.md)
