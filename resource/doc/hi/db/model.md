# त्वरित प्रारंभ

webman मॉडल [Eloquent ORM](https://laravel.com/docs/7.x/eloquent) पर आधारित है। प्रत्येक डेटाबेस तालिका के लिए एक अनुसरणी "मॉडल" होता है जिससे उस तालिका के साथ संवाद किया जा सकता है। आप मॉडल का उपयोग करके डेटाबेस तालिका से डेटा प्राप्त कर सकते हैं, साथ ही नए रिकॉर्ड तालिका में डाल सकते हैं।

शुरुआत करने से पहले, कृपया `config/database.php` में डेटाबेस कनेक्शन को कॉन्फ़िगर किया गया है यह सुनिश्चित करें।

> ध्यान दें: Eloquent ORM मॉडल दर्शक को समर्थन करने के लिए अतिरिक्त "composer require" "illuminate/events" की आवश्यकता है [उदाहरण](#मॉडल-दर्शक)

## उदाहरण
```php
<?php
namespace app\model;

use support\Model;

class User extends Model
{
    /**
     * मॉडल के साथ संबंधित तालिका का नाम
     *
     * @var string
     */
    protected $table = 'user';

    /**
     * पुनर्निर्धारित की गई प्रमुख कुंजी, मूल रूप से id होती है
     *
     * @var string
     */
    protected $primaryKey = 'uid';

    /**
     * स्वत: समय-चिह्न रखने की संकेत देना
     *
     * @var bool
     */
    public $timestamps = false;
}
```

## तालिका का नाम
आप एक संज्ञानी "तालिका" को निर्धारित करने के लिए मॉडल पर table गुणवत्ता को परिभाषित करके साथी डेटा तालिका को निर्दिष्ट कर सकते हैं:
```php
class User extends Model
{
    /**
     * मॉडल के साथ संबंधित तालिका का नाम
     *
     * @var string
     */
    protected $table = 'user';
}
```

## प्रमुख कुंजी
Eloquent यह भी मानता है की प्रत्येक डेटा तालिका में एक id नामक मुख्य कुंजी स्तंभ होगा। आप एक संरक्षित $primaryKey गुणवत्ता को पुनर्विचार निर्धारित करने के लिए इस आसपास बदल सकते हैं।
```php
class User extends Model
{
    /**
     * पुनर्निर्धारित प्रमुख कुंजी, मूल रूप से id है
     *
     * @var string
     */
    protected $primaryKey = 'uid';
}
```

Eloquent नमूना में मुख्य कुंजी को एक स्वयं वृद्धि के पूर्व चित्रित पूर्णांक मान मानता है, यह मतलब है कि डिफ़ॉल्ट रूप से प्रमुख कुंजी स्वचालित रूप से int प्रकार में रूपांतरित होगी। यदि आप चाहते हैं की इस्तेमाल किया जाए बढ़ा नहीं या अंकों वाली प्रमुख कुंजी, तो आपको एक सार्वजनिक $incrementing गुणवत्ता को अनुस्तान करने के लिए set सेट करना होगा:
```php
class User extends Model
{
    /**
     * मॉडल प्रमुख कुंजी का जासूस करती है कि वह ऊंचा चल रहा है
     *
     * @var bool
     */
    public $incrementing = false;
}
```

यदि आपकी प्रमुख कुंजी एक पूर्णांक नहीं है, तो आपको मॉडल पर संरक्षित $keyType गुणवत्ता को स्ट्रिंग के रूप में सेट करना होगा:
```php
class User extends Model
{
    /**
     * स्वचालित बढ़ती आईडी "प्रकार"।
     *
     * @var string
     */
    protected $keyType = 'string';
}
```

## समय-चिह्न
डिफ़ॉल्ट रूप से, Eloquent अपेक्षा करता है की आपकी डेटा तालिका में created_at और updated_at दोनों उपलब्ध होंगे। यदि आप नहीं चाहते कि Eloquent इन दो स्तंभों को स्वचालित रूप से प्रबंधित करें, कृपया मॉडल में $timestamps गुणवत्ता को असत्य सेट करें।
```php
class User extends Model
{
    /**
     * स्वचालित रूप से समय-चिह्न को निर्दिष्ट करती है
     *
     * @var bool
     */
    public $timestamps = false;
}
```
यदि आपको समय-चिह्न की संग्रहण फ़ॉर्मेट को निर्धारित करना होता है, तो कृपया अपने मॉडल में $dateFormat गुणवत्ता सेट करें। यह गुणवत्ता तारीख गुणवत्ता को डेटाबेस में भंडारित करने के तरीके को निर्धारित करती है, और मॉडल के सरटाइजिंग को एरे या JSON के रूप में के ढंग को।
```php
class User extends Model
{
    /**
     * समय-चिह्न संग्रहण प्रारूप
     *
     * @var string
     */
    protected $dateFormat = 'U';
}
```

यदि आपको समय-चिह्न के भंडारण की फ़ील्ड नाम को निर्धारित करना होता है, तो कृपया मॉडल में CREATED_AT और UPDATED_AT स्थाई का मूल्य सेट करने के लिए संरक्षित करें:
```php
class User extends Model
{
    const CREATED_AT = 'creation_date';
    const UPDATED_AT = 'last_update';
}
```

## डेटाबेस कनेक्शन
डिफ़ॉल्ट रूप से, Eloquent मॉडल आपके ऐप कॉन्फ़िगर किये जाने वाले डिफ़ॉल्ट डेटाबेस कनेक्शन का उपयोग करेगा। यदि आप मॉडल के लिए एक विभिन्न कनेक्शन निर्दिष्ट करना चाहते हैं, तो कृपया $connection गुणवत्ता को सेट करें:
```php
class User extends Model
{
    /**
     * मॉडल का कनेक्शन नाम
     *
     * @var string
     */
    protected $connection = 'connection-name';
}
```

## डिफ़ॉल्ट गुणवत्ता
यदि किसी मॉडल के कुछ गुणवत्ताओं के लिए डिफ़ॉल्ट मान निर्धारित करना चाहते हैं, तो आप मॉडल पर $attributes गुणवत्ता को परिभाषित कर सकते हैं:
```php
class User extends Model
{
    /**
     * मॉडल के डिफ़ॉल्ट गुणवत्ताएँ।
     *
     * @var array
     */
    protected $attributes = [
        'delayed' => false,
    ];
}
```

## मॉडल खोज
मॉडल और उस से संबंधित डेटाबेस तालिका का निर्माण करने के बाद, आप डेटाबेस से डेटा क्वेरी कर सकते हैं। हर Eloquent मॉडल को एक शक्तिशाली क्वेरी निर्माणकर्ता के रूप में सोचें, जिसका उपयोग आप उससे संबंधित डेटाबेस तालिका को तेज़ी से क्वेरी करने के लिए कर सकते हैं। जैसे:
```php
$users = app\model\User::all();

foreach ($users as $user) {
    echo $user->name;
}
```
> सुझाव: क्योंकि Eloquent मॉडल भी क्वेरी निर्माणकर्ता होते हैं, इसलिए आपको [क्वेरी निर्माणकर्ता](queries.md) में उपलब्ध सभी विधियों को पढ़ना चाहिए। आप इन विध
## संग्रह खोज

आपको कनकटर बिल्डर द्वारा प्रदान की गई count, sum और max विधियों का उपयोग करके, और अन्य संग्रह समारोह फ़ंक्शनों का उपयोग करके संग्रह को संचालित करने की सुविधा भी होती है। ये विधियाँ केवल सही संकेतिक मूल्य प्राप्त कराएंगी और मॉडल उदाहरण नहीं:

```php
$count = app\model\Flight::where('active', 1)->count();

$max = app\model\Flight::where('active', 1)->max('price');
```

## इंजेक्शन

संचालन डेटाबेस में एक पंक्ति जोड़ने के लिए, सबसे पहले एक नया मॉडल उदाहरण बनाएं, उदाहरण को गुण सेट करें, और फिर save विधि को बुलाएँ:
```php
<?php

namespace app\controller;

use app\model\User;
use support\Request;
use support\Response;

class FooController
{
    /**
     * उपयोगकर्ता सारणी में नया रिकॉर्ड जोड़ें
     *
     * @param  Request  $request
     * @return Response
     */
    public function store(Request $request)
    {
        // अनुरोध सत्यापन

        $user = new User;

        $user->name = $request->get('name');

        $user->save();
    }
}
```

created_at और updated_at टाइमस्टैम्प स्वचालित रूप से सेट हो जाएगा (मॉडल में $timestamps गुण सत्य होने पर), हाथ से मान निर्धारित करने की आवश्यकता नहीं है।


## अपडेट

save विधि का उपयोग डेटाबेस में पहले से मौजूद मॉडल को अपडेट करने के लिए भी किया जा सकता है। मॉडल को अपडेट करने के लिए, आपको सबसे पहले उसे अपडेट करने के लिए पुनरीक्षण करना होगा, विशेषता को सेट करना होगा, और फिर save विधि को बुलाना होगा। इसी तरह, updated_at टाइमस्टैम्प स्वचालित रूप से अपडेट हो जाएगा, ऐसा करने के लिए हाथ से मान निर्धारित करने की आवश्यकता नहीं है:
```php
$user = app\model\User::find(1);
$user->name = 'jerry';
$user->save();
```

## बैच अपडेट

```php
app\model\User::where('uid', '>', 10)
          ->update(['name' => 'tom']);
```

## गुण परिवर्तन की जांच

Eloquent ने isDirty, isClean और wasChanged विधियां प्रदान की हैं, जो मॉडल की आंतरिक स्थिति की जांच करती हैं और यह निर्धारित करती है कि उसकी विशेषताएँ प्रारंभ लोड के समय से कैसे बदली हैं। isDirty विधि मॉडल को स्वयं से लोड होने के बाद क्या कोई विशेषता परिवर्तित हो गई है, यह निर्धारित करती है। आप विशेष विशेषता नाम भी भेज सकते हैं ताकि विशिष्ट गुण की व्यवस्था की जा सके। isClean विधि isDirty के विलोम है, यह भी वैकल्पिक विशेषता पैरामीटर स्वीकार करती है:
```php
$user = User::create([
    'first_name' => 'Taylor',
    'last_name' => 'Otwell',
    'title' => 'Developer',
]);

$user->title = 'Painter';

$user->isDirty(); // true
$user->isDirty('title'); // true
$user->isDirty('first_name'); // false

$user->isClean(); // false
$user->isClean('title'); // false
$user->isClean('first_name'); // true

$user->save();

$user->isDirty(); // false
$user->isClean(); // true
```
wasChanged विधि निर्धारित करती है कि वर्तमान अनुरोध चक्र के दौरान अंतिम बार मॉडल को संचय करने पर क्या कोई विशेषता बदली है। आप विशेष गुण का नाम भी पार कर सकते हैं ताकि केवल विशिष्ट गुण की जांच की जा सके:
```php
$user = User::create([
    'first_name' => 'Taylor',
    'last_name' => 'Otwell',
    'title' => 'Developer',
]);

$user->title = 'Painter';
$user->save();

$user->wasChanged(); // true
$user->wasChanged('title'); // true
$user->wasChanged('first_name'); // false
```

## बैच देना

आप नए मॉडल को सहेजने के लिए create विधि का उपयोग कर सकते हैं। इस विधि मॉडल उदाहरण वापस देती है। लेकिन, उपयोग से पहले, आपको मॉडल पर fillable या guarded गुण निर्धारित करने की आवश्यकता है, क्योंकि सभी Eloquent मॉडल डिफ़ॉल्ट रूप से योग्यता के लिए नहीं होते हैं।

जब उपयोगकर्ता डेटाबेस में अप्रत्याशित HTTP पैरामीटर प्राप्त करता है, और वह पैरामीटर उसके द्वारा नहीं बदले जाने वाले फ़ील्ड को बदल देता है, तो बैच देने की चीज़ हो सकती है। जैसे: दुर्भाग्यपूर्ण उपयोगकर्ता संस्करण पैरामीटर के माध्यम से पार कर सकता है, और फिर इसे create विधि को पास कर सकता है, इस क्रिया से उपयोगकर्ता अपने आपको प्रबंधक बना सकते हैं।

लेकिन, इससे पहले कि आप शुरू करें, आपको तय करना चाहिए कि मॉडल पर कौनसी विशेषताएँ बैच देने के लिए योग्य हैं। आप मॉडल पर $fillable गुण का उपयोग करके यह प्राप्त कर सकते हैं। उदाहरण के लिए: फ्लाइट मॉडल की नाम विशेषता को द्वारा बैच देने के लिए योग्य बनाएं:

```php
<?php

namespace app\model;

use support\Model;

class Flight extends Model
{
    /**
     * बैच दिया जा सकने वाली विशेषताएँ।
     *
     * @var array
     */
    protected $fillable = ['name'];
}
```

जैसे ही हमने योग्यता के लिए विशेषताएँ निर्धारित कर ली है, हम create विधि का उपयोग करके डेटाबेस में नया डेटा डाल सकते हैं। create विधि बचाया गया मॉडल उदाहरण लौटाएगी:
```php
$flight = app\model\Flight::create(['name' => 'Flight 10']);
```
यदि आपके पास पहले से मॉडल उदाहरण है, तो आप fill विधि को कॉल करके एक एरे को पास कर सकते हैं:
```php
$flight->fill(['name' => 'Flight 22']);
```

$fillable को बैच देने की "सफेद सूची" के रूप में देखा जा सकता है, आप $guarded गुण का उपयोग करके भी प्राप्ति कर सकते हैं। $guarded गुण में वह विशेषताएँ शामिल होती हैं जो बैच दिये जाने के लिए योग्य नहीं हैं। दोनों में से केवल एक ही उपयोग कर सकते हैं। ध्यान दें: आपको केवल $fillable या $guarded दोनों में से एक ही उपयोग कर सकते हैं, उन्हें साथ में उपयोग नहीं किया जा सकता। नीचे दिए गए उदहारण में, कीमत विशेषता के बहार के सभी विशेषताएँ बैच दिये जा सकते हैं:

```php
<?php

namespace app\model;

use support\Model;

class Flight extends Model
{
    /**
     * बैच दिये जाने वाली विशेषताएँ।
     *
     * @var array
     */
    protected $guarded = ['price'];
}
```

यदि आप सभी विशेषताएँ बैच दिये जाने के लिए अनुमति देना चाहते हैं, तो आप $guarded को एक खाली एरे के रूप में निर्धारित कर सकते हैं:
```php
/**
 * बैच दिये जाने वाली विशेषताएँ।
 *
 * @var array
 */
protected $guarded = [];
```

## अन्य निर्माण विधियाँ
firstOrCreate/ firstOrNew
यहाँ दो विधियाँ हैं जिन्हें आप बैच दिये जाने के लिए उपयोग कर सकते हैं: firstOrCreate और firstOrNew। firstOrCreate विधि दिए गए कुंजी / मान जोड़के डेटाबेस में डेटा की मिलान करने का प्रयास करेगी। यदि डेटाबेस में मॉडल नहीं मिलता है, तो इसमें पहले पैरामीटर की विशेषता और वैकल्पिक दूसरे पैरामीटर की विशेषता शामिल होगी।

firstOrNew विध
