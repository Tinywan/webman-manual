# नियंत्रक

नई नियंत्रक फ़ाइल `app/controller/FooController.php` बनाएँ।

```php
<?php
namespace app\controller;

use support\Request;

class FooController
{
    public function index(Request $request)
    {
        return response('hello index');
    }
    
    public function hello(Request $request)
    {
        return response('hello webman');
    }
}
```

`http://127.0.0.1:8787/foo` पर पहुँच करते समय, पृष्ठ `hello index` वापस देगा।

`http://127.0.0.1:8787/foo/hello` पर पहुँच करते समय, पृष्ठ `hello webman` वापस देगा।

बेशक, आप मार्गनिर्धारण के माध्यम से मार्गनिर्धारण नियमों को बदल सकते हैं, [मार्ग](route.md) देखें।

> **सुझाव**
> यदि 404 यातायात नहीं हो पा रहा है, तो `config/app.php` खोलें, `controller_suffix` को `Controller` के रूप में सेट करें, और पुनः आरंभ करें।

## नियंत्रक संकेत
1.3 संस्करण से webman क्ंापन के बाद से नियंत्रक प्रतिलोय की अनुमति है, यदि `config/app.php` में `controller_suffix` को रिक्त `' '` से सेट किया है, तो नियंत्रक ऐसा दिखता है

`app\controller\Foo.php`।

```php
<?php
namespace app\controller;

use support\Request;

class Foo
{
    public function index(Request $request)
    {
        return response('hello index');
    }
    
    public function hello(Request $request)
    {
        return response('hello webman');
    }
}
```

नियंत्रक को`Controller` रूपभव से सेट करना शक्तिशाली रूप से अनुशंसा की जाती है, जिससे नियंत्रक और मॉडल कक नाम पर टक्कर ना लगे, साथ ही सुरक्षा बढ़ी हो।

## विवरण
 - फ़्रेमवर्क ज़स्ती से नियंत्रक को `support\Request` ऑब्जेक्ट पास करता है, जिसके माध्यम से उपयोक्ता इनपुट डाटा (get post header cookie आदि डेटा) प्राप्त किया जा सकता है, देखें[अनुरोध](request.md)
 - नियंत्रक से नंम्बर, स्त्रिंग या `support\Response` ऑब्जेक्ट वापस किया जा सकता है, लेकिन इसके अलावा किसी अन्य प्रकार के डेटा वापस नहीं किया जा सकता।
 - `support\Response` ऑब्जेक्ट को `response()` `json()` `xml()` `jsonp()` `redirect()` इत्यादि हेल्पर फ़ंक्शन के माध्यम से बनाया जा सकता है।

## नियंत्रक जीवनकाल

जब `config/app.php` में `controller_reuse` की मान `false` होती है, तो प्रत्येक अनुरोध के लिए संबंधित नियंत्रक उदाहरण का एक नया उदाहरण बनाया जाएगा, अनुरोध समाप्त होने के बाद नियंत्रक उदाहरण नष्ट हो जाएगा, यह पारंपरिक फ़्रेमवर्क की प्रक्रिया के समान होता है।

जब `config/app.php` में `controller_reuse` की मान `true` होती है, तो सभी अनुरोध नियंत्रक उदाहरण को पुन: प्रयोग करेंगे, यानी एक बार नियंत्रक उदाहरण बनाए जाने पर वह मेमरी में बना रहेगा, सभी अनुरोध पुनरुपयोग करेंगे।

> **ध्यान दें**
> नियंत्रक पुन: प्रयोग को बंद करने के लिए webman>=1.4.0 की आवश्यकता है, अर्थात पहले 1.4.0 में नियंत्रक को डिफ़ॉल्ट रूप से सभी अनुरोध पुनरुपयोग करता था, जिसे बदला नहीं जा सकता।

> **ध्यान दें**
> नियंत्रक पुन: प्रयोग को शुरू करने पर, अनुरोधवार कोई भी नियंत्रक गुण संशोधित नहीं करना चाहिए, क्योंकि इन संशोधनों से पछतावा होगा। उदाहरण के रूप में:

```php
<?php
namespace app\controller;

use support\Request;

class FooController
{
    protected $model;
    
    public function update(Request $request, $id)
    {
        $model = $this->getModel($id);
        $model->update();
        return response('ok');
    }
    
    public function delete(Request $request, $id)
    {
        $model = $this->getModel($id);
        $model->delete();
        return response('ok');
    }
    
    protected function getModel($id)
    {
        // इस मेथड को पहले अनुरोध update?id=1 के बाद मॉडल को बचा रखे जाएगा
        // फिर से अनुरोध delete?id=2 करने पर, 1 के मानदंड समाप्त हो जाएगा
        if (!$this->model) {
            $this->model = Model::find($id);
        }
        return $this->model;
    }
}
```

> **सुझाव**
> नियंत्रक `__construct()` निर्माणक रूप में डेटा वापसी का कोई प्रभाव नहीं होगा, उदाहरण के रूप में

```php
<?php
namespace app\controller;

use support\Request;

class FooController
{
    public function __construct()
    {
        // निर्माणक रूप में डेटा वापसी का कोई प्रभाव नहीं होता है, ब्राउज़र को इस प्रतिक्रिया को प्राप्त नहीं होगा
        return response('hello'); 
    }
}
```

## नियंत्रक पुनरुपयोग और अपुनरुपण में अंतर
अंतर इस प्रकार है

#### उपयोगकर्ता द्वारा नियंत्रक का पुराना उपयोग नहीं किया गया
प्रत्येक अनुरोध के लिए आपको प्रत्येक बार वही नियंत्रक उदाहरण नया बनाना पड़ता है, अनुरोध समाप्त होने के बाद वह उदाहरण मिटा दिया जाएगा, और मेमरी संग्रहाण किया जाएगा। नियंत्रक पुनःप्रयोग न करना और पारंपरिक फ़्रेमवर्क करना होता है, जो अधिकांश डेवलपर की आदतों के अनुरूप है। नियंत्रक के यातायात को बार-बार बनाने और नष्ट करने के कारण, इसलिए प्रदर्शन पुनरुपण नियंत्रक प्रणाली की तुलना में थोड़ा पिछड़ा होगा (हैलोवर्ड परखने का प्रदर्शन लगभग 10% कम होगा, व्यावसायिक लक्षक को बेहद क्षितिज रूप में देखा जा सकता है)

#### नियंत्रक पुराना उपयोग
यदि उपयोगकर्ता नियंत्रक के संस्थानों को बदल सकते हैं, तो नियंत्रक पुराना उपयोग नहीं कर सकते, क्योंकि इन संस्थानों के संशोधन बाद के अनुरोधों पर प्रभाव डालेंगे।

कुछ डेवलपर नियंत्रक निर्माण करने के लिए `__construct()` में प्रत्येक अनुरोध के लिए निर्माण करना पसंद करते हैं, ऐसे समय में नियंत्रक पुराना उपयोग नहीं किया जा सकता, क्योंकि मौजूदा प्रक्रिया निर्माण केवल एक बार ही बुलाई जाती है, और हर अनुरोध को नहीं बुलाया जाता।
