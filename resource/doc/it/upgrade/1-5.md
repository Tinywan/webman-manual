# Guida all'aggiornamento 1.5

**Si consiglia di eseguire il backup prima di procedere con l'aggiornamento, quindi eseguire i seguenti comandi**
`composer require workerman/webman-framework ^1.5 -W && composer require webman/console ^1.2.12 && php webman install`

# Caratteristiche e cambiamenti

Supporto per workerman v5 [coroutine](https://www.workerman.net/doc/workerman/fiber.html)

> **Nota**
> workerman v5 richiede PHP>=8.1
> Il comando di aggiornamento di workerman è `composer require workerman/workerman ^5.0.0 -W`
> Le coroutine Fiber richiedono l'installazione di `composer require revolt/event-loop ^1.0.0`

# Esempi
### Risposta ritardata

```php
<?php

namespace app\controller;

use support\Request;
use Workerman\Timer;

class TestController
{
    public function index(Request $request)
    {
        // Dorme per 1,5 secondi
        Timer::sleep(1.5);
        return $request->getRemoteIp();
    }
}
```
`Timer::sleep()` è simile alla funzione `sleep()` predefinita di PHP, l'unica differenza è che `Timer::sleep()` non bloccherà il processo.

### Effettuare richieste HTTP

> **Nota**
> È necessario installare composer require workerman/http-client ^2.0.0

```php
<?php

namespace app\controller;

use support\Request;
use Workerman\Http\Client;

class TestController
{
    public function index(Request $request)
    {
        static $client;
        $client = $client ?: new Client();
        $response = $client->get('http://example.com'); // Effettua una richiesta asincrona tramite un metodo sincrono
        return $response->getBody()->getContents();
    }
}
```
Anche la richiesta `$client->get()` è non bloccante. Questo può essere utilizzato per gestire in modo non bloccante le richieste http in webman, migliorandone le prestazioni.

Per ulteriori informazioni, consultare [workerman/http-client](https://www.workerman.net/doc/workerman/components/workerman-http-client.html)

### Aggiunta classe support\Context

La classe support\Context è utilizzata per memorizzare i dati relativi alle richieste e tali dati vengono eliminati automaticamente al termine della richiesta. Ciò significa che il ciclo di vita dei dati di contesto segue il ciclo di vita delle richieste.

### Inquinamento delle variabili globali

L'ambiente delle coroutine vieta di memorizzare le informazioni di stato **relative alle richieste** in variabili globali o statiche, poiché ciò potrebbe comportare inquinamento delle variabili globali, ad esempio

```php
<?php

namespace app\controller;

use support\Request;
use Workerman\Timer;

class TestController
{
    protected static $name = '';

    public function index(Request $request)
    {
        static::$name = $request->get('name');
        Timer::sleep(5);
        return static::$name;
    }
}
```

Impostando il numero di processi su 1, quando si inviano due richieste consecutive
http://127.0.0.1:8787/test?name=lilei
http://127.0.0.1:8787/test?name=hanmeimei
speriamo che i risultati restituiti dalle due richieste siano rispettivamente `lilei` e `hanmeimei`, ma in realtà entrambi restituiscono `hanmeimei`.
Ciò è dovuto al fatto che la seconda richiesta sovrascrive la variabile statica `$name`, quindi quando la prima richiesta completa l'attesa, restituisce il valore di `$name` che è diventato `hanmeimei`.

**Il modo corretto è utilizzare la memorizzazione dei dati di stato della richiesta in context**
```php
<?php

namespace app\controller;

use support\Request;
use support\Context;
use Workerman\Timer;

class TestController
{
    public function index(Request $request)
    {
        Context::set('name', $request->get('name'));
        Timer::sleep(5);
        return Context::get('name');
    }
}
```

**Le variabili locali non causeranno inquinamento dei dati**
```php
<?php

namespace app\controller;

use support\Request;
use support\Context;
use Workerman\Timer;

class TestController
{
    public function index(Request $request)
    {
        $name = $request->get('name');
        Timer::sleep(5);
        return $name;
    }
}
```
Poiché `$name` è una variabile locale, le coroutine non possono accedere reciprocamente alle variabili locali, pertanto l'utilizzo di variabili locali è sicuro per le coroutine.

# Riguardo alle coroutine
Le coroutine non sono una soluzione universale, l'introduzione delle coroutine significa che è necessario prestare attenzione all'inquinamento delle variabili globali/variabili statiche e alla gestione dell'ambiente del contesto. Inoltre, il debugging dei bug in un ambiente di coroutine è più complesso rispetto alla programmazione bloccante.

La programmazione bloccante con webman è già abbastanza veloce. Secondo i dati di stress test degli ultimi tre anni su [techempower.com](https://www.techempower.com/benchmarks/#section=data-r21&l=zijnjz-6bj&test=db&f=1ekg-cbcw-2t4w-27wr68-pc0-iv9slc-0-1ekgw-39g-kxs00-o0zk-4fu13d-2x8do8-2), la programmazione bloccante con webman con attività di database è quasi due volte più veloce dei framework web go come gin, echo, e quasi 40 volte più veloce dei framework tradizionali come laravel.
![](../../assets/img/benchemarks-go-sw.png?)

Quando il database, redis, etc. sono tutti in rete locale, le prestazioni della programmazione bloccante con multiprocessi spesso sono migliori delle coroutine, in quanto i costi di creazione, schedulazione e terminazione delle coroutine possono superare i costi di cambio di processo quando il database e redis sono sufficientemente veloci. Pertanto, l'introduzione delle coroutine in questi casi potrebbe non migliorare significativamente le prestazioni.

# Quando utilizzare le coroutine
Quando c'è un accesso lento nell'applicazione, ad esempio quando l'applicazione deve accedere a un'API di terze parti, è possibile utilizzare [workerman/http-client](https://www.workerman.net/doc/workerman/components/workerman-http-client.html) per effettuare chiamate HTTP asincrone come coroutine, migliorando la capacità di concorrenza dell'applicazione.
