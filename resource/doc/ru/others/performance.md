# Производительность webman


### Процесс обработки запросов в традиционных фреймворках

1. nginx/apache получают запрос
2. nginx/apache передают запрос в php-fpm
3. php-fpm инициализирует среду, такую как создание списка переменных
4. php-fpm вызывает RINIT различных расширений/модулей
5. php-fpm читает php-файл с диска (использование opcache позволяет избежать этого)
6. php-fpm проводит лексический анализ, синтаксический анализ, компиляцию в opcode (использование opcache позволяет избежать этого)
7. php-fpm выполнение opcode, включая 8.9.10.11
8. Инициализация фреймворка, такая как создание экземпляров различных классов, включая контейнер, контроллер, маршрутизатор, промежуточное ПО и т.д.
9. Фреймворк устанавливает связь с базой данных и проводит проверку прав доступа, устанавливает соединение с redis
10. Фреймворк выполняет бизнес-логику
11. Фреймворк закрывает соединение с базой данных и redis
12. php-fpm освобождает ресурсы, уничтожает все определения классов и экземпляры, уничтожает таблицу символов и т.д.
13. php-fpm последовательно вызывает методы RSHUTDOWN различных расширений/модулей
14. php-fpm пересылает результат nginx/apache
15. nginx/apache возвращает результат клиенту


### Процесс обработки запросов в webman
1. Фреймворк получает запрос
2. Фреймворк выполняет бизнес-логику
3. Фреймворк возвращает результат клиенту

Да, в отсутствие обратного прокси nginx, у фреймворка всего лишь 3 шага. Можно сказать, что это уже предел для фреймворка на php, что делает производительность webman в несколько или даже десятки раз выше, чем у традиционных фреймворков.

Для более подробной информации смотрите [Тесты нагрузки](benchmarks.md)
