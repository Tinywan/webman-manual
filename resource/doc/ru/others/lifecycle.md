# Жизненный цикл

## Цикл жизни процесса
- У каждого процесса долгий жизненный цикл
- Каждый процесс работает независимо и не взаимодействует друг с другом
- Каждый процесс может обрабатывать несколько запросов в течение своего жизненного цикла
- При получении команды `stop`, `reload`, `restart` процесс завершает текущий жизненный цикл и завершает работу

> **Совет**
> Каждый процесс работает независимо от других, что означает, что каждый процесс поддерживает свои собственные ресурсы, переменные и экземпляры классов, что проявляется в том, что каждый процесс имеет свое собственное соединение с базой данных, некоторые синглтоны инициализируются в каждом процессе, что приводит к нескольким инициализациям во время работы нескольких процессов.

## Жизненный цикл запроса
- Каждый запрос порождает объект `$request`
- Объект `$request` уничтожается после завершения обработки запроса

## Жизненный цикл контроллера
- Каждый контроллер будет создан только один раз для каждого процесса; для нескольких процессов будет создано несколько экземпляров (исключение составляет контроллер без возможности повторного использования, см. [Жизненный цикл контроллера](https://www.workerman.net/doc/webman/controller.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F))
- Экземпляр контроллера будет общим для нескольких запросов в текущем процессе (исключение составляет контроллер без возможности повторного использования)
- Жизненный цикл контроллера завершается после выхода из процесса (исключение составляет контроллер без возможности повторного использования)

## Жизненный цикл переменных
Webman разработан на основе PHP, поэтому полностью соблюдает механизм сборки мусора PHP. Локальные переменные, созданные в бизнес-логике, включая созданные с помощью ключевого слова `new` экземпляры классов, автоматически удаляются после завершения функции или метода без необходимости ручного освобождения с помощью `unset`. Это означает, что опыт разработки с использованием webman практически идентичен традиционной разработке на других фреймворках. Например, экземпляр `$foo` в следующем примере будет автоматически освобожден после завершения метода index:
```php
<?php

namespace app\controller;

use app\service\Foo;
use support\Request;

class IndexController
{
    public function index(Request $request)
    {
        $foo = new Foo(); // Предположим, что здесь есть класс Foo
        return response($foo->sayHello());
    }
}
```
Если вы хотите, чтобы экземпляр определенного класса был повторно использован, то можно сохранить класс в статическом свойстве класса или свойстве объекта с долгим циклом жизни (например, контроллером), а также использовать метод get контейнера для инициализации экземпляра класса, например:
```php
<?php

namespace app\controller;

use app\service\Foo;
use support\Container;
use support\Request;

class IndexController
{
    public function index(Request $request)
    {
        $foo = Container::get(Foo::class);
        return response($foo->sayHello());
    }
}
```
Метод `Container::get()` используется для создания и сохранения экземпляра класса, который будет возвращен при следующем вызове с теми же параметрами.

> **Внимание**
> `Container::get()` может инициализировать только экземпляры без параметров конструктора. `Container::make()` может создавать экземпляры с параметрами конструктора, однако, в отличие от `Container::get()`, `Container::make()` не будет повторно использовать экземпляр, то есть даже при вызове с теми же параметрами, `Container::make()` всегда будет возвращать новый экземпляр.

# О утечках памяти
В большинстве случаев наш бизнес-код не вызывает утечек памяти (пользователи очень редко жалуются на утечки памяти), нужно лишь следить за тем, чтобы долговременные массивы данных не расширялись бесконечно. Посмотрите следующий код:
```php
<?php
namespace app\controller;

use support\Request;

class FooController
{
    // Свойство массива
    public $data = [];
    
    public function index(Request $request)
    {
        $this->data[] = time();
        return response('hello index');
    }

    public function hello(Request $request)
    {
        return response('hello webman');
    }
}
```
По умолчанию контроллеры имеют долгий цикл жизни (исключение составляет контроллер без возможности повторного использования), и также свойство массива `$data` контроллера имеет долгий жизненный цикл. По мере увеличения количества запросов `foo/index` элементы массива `$data` будут накапливаться, что приведет к утечке памяти.

Дополнительную информацию см. в разделе [Утечки памяти](./memory-leak.md)
