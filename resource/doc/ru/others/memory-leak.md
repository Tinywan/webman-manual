# Об утечках памяти
Webman - это постоянный фреймворк, поэтому нам нужно слегка обратить внимание на возможные утечки памяти. Однако разработчику не нужно слишком беспокоиться, потому что утечки памяти происходят в очень экстремальных условиях и их легко избежать. Разработка веб-приложений с использованием Webman практически не отличается от разработки с использованием традиционных фреймворков, поэтому нет необходимости выполнять лишние операции по управлению памятью.

> **Подсказка**
> Монитор процессов, включенный в Webman, отслеживает использование памяти всеми процессами. Если процесс использует память, которая почти достигает установленного значения `memory_limit` в php.ini, процесс будет автоматически безопасно перезапущен, что позволяет освободить память без влияния на бизнес-логику.

## Определение утечек памяти
С увеличением количества запросов, потребление памяти Webman также **бесконечно увеличивается** (обратите внимание, что **бесконечно увеличивается**), достигая нескольких сотен мегабайт, или даже больше, это называется утечка памяти. Если потребление памяти увеличивается, но затем перестает увеличиваться, это не считается утечкой памяти.

Обычно использование нескольких десятков мегабайт памяти процессом является нормальной ситуацией. Когда процесс обрабатывает очень большой запрос или поддерживает огромное количество подключений, потребление памяти одного процесса может достигать нескольких сотен мегабайт, что также является обычной ситуацией. После использования памяти php возможно, что не все память будет возвращена операционной системе. Вместо этого она остается для повторного использования, поэтому может возникнуть ситуация, когда использование памяти увеличивается после обработки большого запроса и не освобождается, что является нормальным явлением. (Метод `gc_mem_caches()` может освободить часть свободной памяти)

## Причины возникновения утечек памяти
**Утечка памяти происходит при выполнении следующих двух условий:**
1. Присутствует **длинный ливень** массива (обратите внимание, что имеется в виду **длинный ливень**, обычный массив не имеет значения)
2. И этот **длинный ливень** массива бесконечно расширяется (бизнес бесконечно добавляет данные в него, при этом не происходит очистки данных).

Если **одновременно выполняются** условия 1 и 2 (обратите внимание, что это одновременное выполнение условий), то возникает утечка памяти. В противном случае отсутствие выполнения указанных выше условий или выполнение только одного из них не считается утечкой памяти.

## Длинный ливень массива
В Webman длинный ливень массива включает в себя:
1. Массивы, определенные с использованием ключевого слова static
2. Свойства массивов синглтона
3. Массивы, определенные с использованием ключевого слова global

> **Примечание**
> В Webman можно использовать длительный массив, но нужно убедиться, что данные внутри массива ограничены, количество элементов не бесконечно увеличивается.

Далее приведем примеры.

#### Бесконечное увеличение static массива
```php
class Foo
{
    public static $data = [];
    public function index(Request $request)
    {
        self::$data[] = time();
        return response('hello');
    }
}
```

Массив `$data`, определенный с использованием ключевого слова `static`, является длинным ливнем массива, и в данном примере массив `$data` увеличивается с увеличением запросов, что приводит к утечке памяти.

#### Бесконечное увеличение свойства массива синглтона
```php
class Cache
{
    protected static $instance;
    public $data = [];
    
    public function instance()
    {
        if (!self::$instance) {
            self::$instance = new self;
        }
        return self::$instance;
    }
    
    public function set($key, $value)
    {
        $this->data[$key] = $value;
    }
}
```

Код вызова
```php
class Foo
{
    public function index(Request $request)
    {
        Cache::instance()->set(time(), time());
        return response('hello');
    }
}
```

`Cache::instance()` возвращает синглтон Cache, который является экземпляром класса с длинным временем жизни, хотя его свойство $data не имеет ключевого слова `static`, но так как сам класс имеет длинный временем жизни, то и $data является длинным ливнем массива. Поскольку массив `$data` продолжает увеличиваться с добавлением разных ключей данных, использование памяти в программе также увеличивается, что приводит к утечке памяти.

> **Примечание**
> Если добавляемый ключ методом Cache::instance()->set(key, value) имеет ограниченное количество, то утечка памяти не произойдет, потому что массив `$data` не будет бесконечно увеличиваться.

#### Бесконечное увеличение глобального массива
```php
class Index
{
    public function index(Request $request)
    {
        global $data;
        $data[] = time();
        return response($foo->sayHello());
    }
}
```
Массив, определенный с ключевым словом global, не освобождается после завершения функции или метода, поэтому он имеет длинный временем жизни, и указанный выше код приведет к утечке памяти с увеличением запросов. Точно так же массивы, объявленные в функции или методе с использованием ключевого слова static, также являются массивами с длинным временем жизни, и если массив бесконечно увеличивается, это также приведет к утечке памяти, например:
```php
class Index
{
    public function index(Request $request)
    {
        static $data = [];
        $data[] = time();
        return response($foo->sayHello());
    }
}
```

## Рекомендации
Разработчикам советуется не слишком беспокоиться о утечках памяти, так как они происходят очень редко. Если, к сожалению, они все же происходят, мы можем найти место в коде, где происходит утечка, путем проведения нагрузочного тестирования и устранить проблему. Даже если разработчик не обнаружит место утечки памяти, мониторинговая служба Webman будет периодически безопасно перезапускать процессы, в которых происходит утечка памяти, для освобождения памяти.

Если вы все равно хотите по возможности избежать утечек памяти, рекомендуется следовать следующим советам.
1. Стремитесь не использовать массивы с ключевыми словами `global` и `static`, и если используете, убедитесь, что они не будут бесконечно увеличиваться.
2. Для незнакомых классов старайтесь избегать использования синглтона, предпочтительнее использовать ключевое слово `new` для инициализации. Если необходимо использовать синглтон, то убедитесь, что у него нет свойств массивов, которые могут бесконечно увеличиваться.

