# Нагрузочное тестирование

### Какие факторы влияют на результаты нагрузочного тестирования?
* Задержка сети от машины для нагрузочного тестирования до сервера (рекомендуется тестирование в локальной сети или на локальной машине)
* Пропускная способность сети от машины для нагрузочного тестирования до сервера (рекомендуется тестирование в локальной сети или на локальной машине)
* Включен ли HTTP keep-alive (рекомендуется включить)
* Достаточно ли конкурентных запросов (при тестировании через интернет рекомендуется использовать более высокую конкурентность)
* Разумно ли количество процессов на сервере (рекомендуется, чтобы количество процессов для бизнеса helloworld было равно количеству процессоров, а для бизнеса баз данных - в 4 раза и больше от количества процессоров)
* Производительность самого бизнеса (например, используется ли внешняя база данных)

### Что такое HTTP keep-alive?
Механизм HTTP Keep-Alive - это технология, используемая для отправки нескольких HTTP-запросов и ответов через одно TCP-соединение. Он имеет значительное влияние на результаты производительности тестирования: отключение keep-alive может привести к уменьшению количества запросов в секунду в несколько раз. 
В настоящее время браузеры по умолчанию включают keep-alive, то есть после доступа к определенному http-адресу браузер временно оставляет соединение открытым для повторного использования при следующем запросе, что помогает улучшить производительность. 
Рекомендуется включать keep-alive при тестировании.

### Как включить HTTP keep-alive при тестировании?
Если вы используете программу ab для тестирования, вам нужно использовать параметр -k, например, `ab -n100000 -c200 -k http://127.0.0.1:8787/`.
apipost должен возвращать заголовок gzip, чтобы включить keep-alive (ошибка apipost, смотрите ниже).
Другие программы для тестирования обычно включают keep-alive по умолчанию.

### Почему QPS при тестировании через интернет очень низкий?
Большая задержка интернета приводит к низкой производительности запросов в секунду, это нормальное явление. Например, тестирование страницы baidu может дать всего несколько десятков запросов в секунду.
Рекомендуется тестировать в локальной сети или на локальной машине, чтобы исключить влияние задержки сети.
Если все же нужно проводить тестирование через интернет, можно повысить конкурентность для увеличения пропускной способности (не забывайте про достаточную пропускную способность).

### Почему производительность падает после проксирования через nginx?
Работа nginx требует ресурсы системы. Кроме того, взаимодействие между nginx и webman также требует определенных ресурсов. 
Тем не менее, ресурсы системы ограничены, и webman не может получить доступ ко всем ресурсам системы, поэтому некоторое падение производительности системы при использовании nginx-прокси является нормальным.
Чтобы минимизировать влияние производительности, можно рассмотреть возможность отключения журналов nginx (`access_log off;`), а также включение keep-alive между nginx и webman, см. [проксирование nginx](nginx-proxy.md).

Кроме того, HTTPS потребляет больше ресурсов по сравнению с HTTP из-за необходимости проведения SSL/TLS-сеанса, шифрования и дополнительного объема данных, что может привести к снижению производительности. 
Если тестирование производится с использованием коротких соединений (без включенного HTTP keep-alive), каждый запрос требует дополнительного SSL/TLS-сеанса, что сильно снижает производительность. Рекомендуется включать HTTP keep-alive при тестировании HTTPS.

### Как узнать, что система достигла предела производительности?
В общем, когда CPU достигает 100%, это означает, что производительность системы достигла предела. Если у CPU еще остается свободное время, значит предел производительности еще не достигнут и можно увеличить конкурентность для повышения QPS.
Если увеличение конкурентности не увеличивает QPS, возможно, причина в недостаточном количестве процессов webman; в таком случае рекомендуется увеличить количество процессов webman. Если QPS все еще не увеличивается, следует рассмотреть, достаточно ли пропускной способности.

### Почему результаты моего нагрузочного тестирования показывают, что производительность webman ниже, чем у фреймворка gin на go?
[techempower](https://www.techempower.com/benchmarks/#section=data-r21&hw=ph&test=db&l=zijnjz-6bj&a=2&f=1ekg-cbcw-2t4w-27wr68-pc0-iv9slc-0-1ekgw-39g-kxs00-o0zk-5jsetl-2x8doc-2) показывает, что webman превосходит gin примерно вдвое по всем параметрам, таким как обработка простого текста, запросы к базе данных и обновления базы данных.
Если ваши результаты отличаются, возможно, это вызвано тем, что вы используете ORM в webman, что приводит к значительным потерям производительности. В таком случае можно попробовать сравнить webman с использованием собственного PDO и gin с использованием собственного SQL.

### На сколько упадет производительность при использовании ORM в webman?
Вот несколько результатов нагрузочного тестирования:

**Среда**
Сервер Alibaba Cloud с 4 ядрами и 4 ГБ памяти, случайный выбор одной записи из 100 000 и возврат JSON.

**При использовании собственного PDO**
QPS для webman составляет 17 800.

**При использовании Db::table() в laravel**
QPS webman падает до 9 400.

**При использовании Model в laravel**
QPS webman падает до 7 200.

Результаты для thinkORM примерно аналогичны. 

> **Подсказка**
> Хотя использование ORM приводит к небольшому снижению производительности, для большинства бизнес-приложений это достаточно. Мы должны находить точку равновесия между производительностью, эффективностью разработки, поддерживаемостью и другими параметрами, а не просто стремиться к повышению производительности.

### Почему при нагрузочном тестировании через apipost QPS так низок?
У модуля нагрузочного тестирования apipost есть ошибка: если сервер не возвращает заголовок gzip, то keep-alive не сохраняется, что приводит к существенному снижению производительности. 
Решением является сжатие данных при возврате и добавление заголовка gzip, например:

```php
<?php
namespace app\controller;
class IndexController
{
    public function index()
    {
        return response(gzencode('hello webman'))->withHeader('Content-Encoding', 'gzip');
    }
}
```
Кроме того, в некоторых случаях apipost может не предоставить удовлетворительную нагрузку, проявляя снижение QPS на 50% по сравнению с ab при том же уровне конкурентности. Для нагрузочного тестирования рекомендуется использовать ab, wrk или другое профессиональное программное обеспечение, а не apipost.

### Настройка подходящего количества процессов
webman по умолчанию имеет число процессов, равное cpu * 4. На практике для бизнеса helloworld без сетевого ввода-вывода количество процессов, равное количеству процессоров, дает оптимальную производительность, так как это позволяет сократить издержки на переключение процессов. Если же речь идет об обработке операций ввода-вывода с блокировкой, количество процессов может быть от 3 до 8 раз больше числа процессоров, чтобы обеспечить большую конкурентность за счет увеличения числа процессов, тогда влияние издержек на переключение процессов при блокировке ввода-вывода можно можно считать пренебрежимо малым.

### Некоторые рекомендуемые значения для нагрузочного тестирования

**Облачный сервер 4 ядра 4 ГБ 16 процессов, тестирование в локальной сети/на локальной машине**

| - | keep-alive включен | keep-alive выключен |
|--|------|------|
| hello world | 80-160 тыс. QPS | 10-30 тыс. QPS |
| единичный запрос к базе данных | 10-20 тыс. QPS | 10 тыс. QPS |

[**Данные нагрузочного тестирования от сторонних поставщиков**](https://www.techempower.com/benchmarks/#section=data-r21&l=zik073-6bj&test=db)

### Примеры команд для нагрузочного тестирования

**ab**
```
# 100000 запросов, 200 конкурентных запросов, включен keep-alive
ab -n100000 -c200 -k http://127.0.0.1:8787/

# 100000 запросов, 200 конкурентных запросов, keep-alive выключен
ab -n100000 -c200 http://127.0.0.1:8787/
```

**wrk**
```
# тестирование с 200 конкурентных запросов в течение 10 секунд, keep-alive включен (по умолчанию)
wrk -c 200 -d 10s http://example.com
```

