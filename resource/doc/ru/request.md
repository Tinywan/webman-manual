# Инструкции

## Получение объекта запроса
Webman автоматически внедряет объект запроса в первый параметр метода действия, например


**Пример**
```php
<?php
namespace app\controller;

use support\Request;

class UserController
{
    public function hello(Request $request)
    {
        $default_name = 'webman';
        // Получение параметра name из GET-запроса, если параметр name не передан, будет возвращено значение $default_name
        $name = $request->get('name', $default_name);
        // Возврат строки в браузер
        return response('Привет, ' . $name);
    }
}
```

С помощью объекта `$request` мы можем получить любые данные, связанные с запросом.

**Иногда мы можем захотеть получить объект `$request` текущего запроса в другом классе, для этого мы можем использовать вспомогательную функцию `request()`**.

## Получение параметра GET-запроса

**Получение всего массива GET**
```php
$request->get();
```
Если в запросе отсутствуют параметры GET, будет возвращен пустой массив.

**Получение значения из массива GET**
```php
$request->get('name');
```
Если в массиве GET отсутствует это значение, будем возвращен `null`.

Также вы можете передать второй параметр методу get в качестве значения по умолчанию, которое будет возвращено, если в массиве GET не будет найдено соответствующего значения, например:
```php
$request->get('name', 'tom');
```

## Получение параметра POST-запроса
**Получение всего массива POST**
```php
$request->post();
```
Если в запросе отсутствуют параметры POST, будет возвращен пустой массив.

**Получение значения из массива POST**
```php
$request->post('name');
```
Если в массиве POST отсутствует это значение, будет возвращен `null`.

Как и метод get, вы можете передать второй параметр методу post в качестве значения по умолчанию, которое будет возвращено, если в массиве POST не будет найдено соответствующего значения, например:
```php
$request->post('name', 'tom');
```

## Получение исходного тела POST-запроса
```php
$post = $request->rawBody();
```
Эта функция аналогична операции `file_get_contents("php://input")` в `php-fpm` и используется для получения исходного тела POST-запроса. Она полезна при получении данных POST-запроса в формате, отличном от `application/x-www-form-urlencoded`. 

## Получение заголовка
**Получение всего массива заголовков**
```php
$request->header();
```
Если в запросе отсутствуют заголовки, будет возвращен пустой массив. Обратите внимание, что все ключи в нижнем регистре.

**Получение значения из массива заголовков**
```php
$request->header('host');
```
Если в массиве заголовков отсутствует это значение, будет возвращен `null`. Обратите внимание, что все ключи в нижнем регистре.

Как и метод get, вы можете передать второй параметр методу header в качестве значения по умолчанию, которое будет возвращено, если в массиве заголовков не будет найдено соответствующего значения, например:
```php
$request->header('host', 'localhost');
```

## Получение данных cookie
**Получение всего массива cookie**
```php
$request->cookie();
```
Если в запросе отсутствуют cookie, будет возвращен пустой массив.

**Получение значения из массива cookie**
```php
$request->cookie('name');
```
Если в массиве cookie отсутствует это значение, будет возвращен `null`.

Как и метод get, вы можете передать второй параметр методу cookie в качестве значения по умолчанию, которое будет возвращено, если в массиве cookie не будет найдено соответствующего значения, например:
```php
$request->cookie('name', 'tom');
```

## Получение всех входных данных
Это включает в себя объединение данных из `post` и `get`.
```php
$request->all();
```

## Получение конкретного входного значения
Получение значения из объединенных данных `post` и `get`.
```php
$request->input('name', $default_value);
```

## Получение части входных данных
Получение части данных из объединенных `post` и `get`.
```php
// Получение массива, состоящего из username и password, игнорируя отсутствующие ключи
$only = $request->only(['username', 'password']);
// Получение всех входных данных, кроме avatar и age
$except = $request->except(['avatar', 'age']);
```

## Получение загруженных файлов
**Получение целого массива загруженных файлов**
```php
$request->file();
```

Аналогично форме:
```html
<form method="post" action="http://127.0.0.1:8787/upload/files" enctype="multipart/form-data" />
<input name="file1" multiple="multiple" type="file">
<input name="file2" multiple="multiple" type="file">
<input type="submit">
</form>
```

Результат вызова `$request->file()` в виде:
```php
array (
    'file1' => object(webman\Http\UploadFile),
    'file2' => object(webman\Http\UploadFile)
)
```
Это массив объектов `webman\Http\UploadFile`. Класс `webman\Http\UploadFile` наследует встроенный в PHP класс [`SplFileInfo`](https://www.php.net/manual/zh/class.splfileinfo.php) и предоставляет некоторые полезные методы.

```php
<?php
namespace app\controller;

use support\Request;

class UploadController
{
    public function files(Request $request)
    {
        foreach ($request->file() as $key => $spl_file) {
            var_export($spl_file->isValid()); // Действителен ли файл, например true|false
            var_export($spl_file->getUploadExtension()); // Расширение загруженного файла, например 'jpg'
            var_export($spl_file->getUploadMimeType()); // MIME-тип загруженного файла, например 'image/jpeg'
            var_export($spl_file->getUploadErrorCode()); // Получение кода ошибки загрузки, например UPLOAD_ERR_NO_TMP_DIR UPLOAD_ERR_NO_FILE UPLOAD_ERR_CANT_WRITE
            var_export($spl_file->getUploadName()); // Имя загруженного файла, например 'my-test.jpg'
            var_export($spl_file->getSize()); // Получение размера файла, например 13364, в байтах
            var_export($spl_file->getPath()); // Получение загруженного каталога, например '/tmp'
            var_export($spl_file->getRealPath()); // Получение пути к временному файлу, например '/tmp/workerman.upload.SRliMu'
        }
        return response('ok');
    }
}
```

**Примечания:**

- После загрузки файл будет назван временным и иметь вид, аналогичный `/tmp/workerman.upload.SRliMu`
- Размер загружаемого файла ограничен [defaultMaxPackageSize](http://doc.workerman.net/tcp-connection/default-max-package-size.html), по умолчанию 10 МБ, значение по умолчанию можно изменить в файле `config/server.php`, изменив `max_package_size`.
- После завершения запроса временный файл будет автоматически очищен
- Если в запросе не загружены файлы, `$request->file()` вернет пустой массив
- Загружаемые файлы не поддерживают метод `move_uploaded_file()`, пожалуйста, используйте метод `$file->move()` вместо него, см. пример ниже

### Получение конкретного загруженного файла
```php
$request->file('avatar');
```
Если файл существует, будет возвращен экземпляр `webman\Http\UploadFile` для соответствующего файла, в противном случае будет возвращен `null`.

**Пример**
```php
<?php
namespace app\controller;

use support\Request;

class UploadController
{
    public function file(Request $request)
    {
        $file = $request->file('avatar');
        if ($file && $file->isValid()) {
            $file->move(public_path().'/files/myfile.'.$file->getUploadExtension());
            return json(['code' => 0, 'msg' => 'Файл успешно загружен']);
        }
        return json(['code' => 1, 'msg' => 'Файл не найден']);
    }
}
```

## Получение хоста
Получение информации о хосте запроса.
```php
$request->host();
```
Если адрес запроса не является стандартным для порта 80 или 443, информация о хосте может содержать порт, например `example.com:8080`. Если порт не нужен, первый параметр можно передать как `true`.

```php
$request->host(true);
```

## Получение метода запроса
```php
 $request->method();
```
Возвращаемое значение может быть `GET`, `POST`, `PUT`, `DELETE`, `OPTIONS` или `HEAD`.

## Получение URI запроса
```php
$request->uri();
```
Возвращает URI запроса, включая часть пути и строки запроса.

## Получение пути запроса

```php
$request->path();
```
Возвращает часть пути запроса.

## Получение строки запроса

```php
$request->queryString();
```
Возвращает строку запроса.

## Получение URL запроса
Метод `url()` возвращает URL без параметра `Query`.
```php
$request->url();
```
Возвращает что-то вроде `//www.workerman.net/workerman-chat`

Метод `fullUrl()` возвращает URL с параметром `Query`.
```php
$request->fullUrl();
```
Возвращает что-то вроде `//www.workerman.net/workerman-chat?type=download`

> **Примечание**
> `url()` и `fullUrl()` не возвращают часть с протоколом (http или https).
> Поскольку в браузере использование адреса с началом `//` автоматически определит протокол текущего сайта и выполнит запрос по http или https.

Если вы используете прокси nginx, добавьте `proxy_set_header X-Forwarded-Proto $scheme;` в конфигурацию nginx, [см. прокси nginx](others/nginx-proxy.md),
чтобы можно было использовать `$request->header('x-forwarded-proto');` для определения http или https, например:
```php
echo $request->header('x-forwarded-proto'); // вывод http или https
```

## Получение версии HTTP запроса

```php
$request->protocolVersion();
```
Возвращает строку `1.1` или `1.0`.

## Получение идентификатора сеанса запроса

```php
$request->sessionId();
```
Возвращает строку, состоящую из букв и цифр.


## Получение IP-адреса клиента

```php
$request->getRemoteIp();
```

## Получение порта клиента
```php
$request->getRemotePort();
```
## Получение реального IP-адреса клиента
```php
$request->getRealIp($safe_mode=true);
```

Когда проект использует прокси (например, nginx), использование `$request->getRemoteIp()` часто приводит к получению IP-адреса прокси-сервера (например, `127.0.0.1` или `192.168.x.x`), а не реального IP-адреса клиента. В этом случае можно попробовать использовать `$request->getRealIp()` для получения реального IP-адреса клиента.

`$request->getRealIp()` пытается получить реальный IP-адрес клиента из заголовков HTTP, таких как `x-real-ip`, `x-forwarded-for`, `client-ip`, `x-client-ip`, `via`.

> Поскольку заголовки HTTP легко подделать, IP-адрес, полученный с помощью этого метода, не является абсолютно достоверным, особенно когда `$safe_mode` установлен в значение false. Более надежным способом получения реального IP-адреса клиента через прокси является знание безопасного IP-адреса прокси-сервера и явное указание, из какого заголовка HTTP следует извлекать реальный IP-адрес с помощью `$request->header('заголовок_с_реальным_IP')`, если IP-адрес, полученный с помощью `$request->getRemoteIp()`, подтверждается как известный безопасный IP-адрес прокси-сервера.

## Получение IP-адреса сервера
```php
$request->getLocalIp();
```

## Получение порта сервера
```php
$request->getLocalPort();
```

## Проверка, является ли запрос ajax-запросом
```php
$request->isAjax();
```

## Проверка, является ли запрос pjax-запросом
```php
$request->isPjax();
```

## Проверка, ожидает ли клиент ответ в формате JSON
```php
$request->expectsJson();
```

## Проверка, принимает ли клиент ответ в формате JSON
```php
$request->acceptJson();
```

## Получение имени плагина запроса
Если запрос не относится к плагину, возвращает пустую строку `''`.
```php
$request->plugin;
```
> Эта функция доступна в webman версии 1.4.0 и выше

## Получение имени приложения запроса
В случае единственного приложения всегда возвращает пустую строку `''`, а в случае [множественных приложений](multiapp.md) возвращает имя приложения.
```php
$request->app;
```

> Поскольку анонимные функции не относятся к каким-либо приложениям, для запросов от маршрутов через анонимные функции `$request->app` всегда возвращает пустую строку `''`.
> См. маршруты через анонимные функции в [маршрутах](route.md)

## Получение имени класса контроллера запроса
Получение имени соответствующего класса контроллера
```php
$request->controller;
```
Возвращает что-то вроде `app\controller\IndexController`

> Поскольку анонимные функции не относятся к каким-либо контроллерам, для запросов от маршрутов через анонимные функции `$request->controller` всегда возвращает пустую строку `''`.
> См. маршруты через анонимные функции в [маршрутах](route.md)

## Получение имени метода запроса
Получение имени метода контроллера, соответствующего запросу
```php
$request->action;
```
Возвращает что-то вроде `index`

> Поскольку анонимные функции не относятся к каким-либо контроллерам, для запросов от маршрутов через анонимные функции `$request->action` всегда возвращает пустую строку `''`.
> См. маршруты через анонимные функции в [маршрутах](route.md)
