# Контроллер

Создайте новый файл контроллера `app/controller/FooController.php`.

```php
<?php
namespace app\controller;

use support\Request;

class FooController
{
    public function index(Request $request)
    {
        return response('hello index');
    }
    
    public function hello(Request $request)
    {
        return response('hello webman');
    }
}
```

При доступе к `http://127.0.0.1:8787/foo` страница вернет `hello index`.

При доступе к `http://127.0.0.1:8787/foo/hello` страница вернет `hello webman`.

Конечно, вы можете изменить правила маршрутизации через конфигурацию маршрутов, см. [Маршруты](route.md).

> **Подсказка**
> Если возникает ошибка 404, откройте файл `config/app.php`, установите `controller_suffix` в `Controller` и перезапустите.

## Суффикс контроллера
С версии 1.3 webman поддерживает установку суффикса контроллера в файле `config/app.php`. Если `controller_suffix` в `config/app.php` установлен на пустую строку `''`, то контроллер будет выглядеть следующим образом:

`app\controller\Foo.php`.

```php
<?php
namespace app\controller;

use support\Request;

class Foo
{
    public function index(Request $request)
    {
        return response('hello index');
    }
    
    public function hello(Request $request)
    {
        return response('hello webman');
    }
}
```

Настоятельно рекомендуется установить суффикс контроллера как `Controller`, чтобы избежать конфликтов имен контроллеров с именами моделей, а также увеличить безопасность.

## Примечание
- Фреймворк автоматически передает объект `support\Request` в контроллер, через который можно получить пользовательские входные данные (GET, POST, заголовки, файлы cookie и т. д.), см. [Запрос](request.md).
- В контроллере можно возвращать числа, строки или объекты `support\Response`, но нельзя возвращать другие типы данных.
- Объекты `support\Response` можно создавать с помощью вспомогательных функций `response()`, `json()`, `xml()`, `jsonp()`, `redirect()` и т. д.

## Жизненный цикл контроллера

Когда `controller_reuse` в `config/app.php` установлен в `false`, для каждого запроса будет инициализироваться новый экземпляр соответствующего контроллера, и по завершении запроса этот экземпляр контроллера будет уничтожен, что аналогично традиционному механизму работы фреймворка.

Когда `controller_reuse` в `config/app.php` установлен в `true`, все запросы будут использовать один и тот же экземпляр контроллера, то есть экземпляр контроллера будет постоянно находиться в памяти и использоваться для всех последующих запросов.

> **Примечание**
> Отключение повторного использования контроллера требуется webman>=1.4.0, то есть до версии 1.4.0 по умолчанию все запросы использовали один и тот же экземпляр контроллера и это не могло быть изменено.

> **Примечание**
> При включении повторного использования контроллера не следует изменять любые свойства контроллера, поскольку эти изменения повлияют на последующие запросы, например:

```php
<?php
namespace app\controller;

use support\Request;

class FooController
{
    protected $model;
    
    public function update(Request $request, $id)
    {
        $model = $this->getModel($id);
        $model->update();
        return response('ok');
    }
    
    public function delete(Request $request, $id)
    {
        $model = $this->getModel($id);
        $model->delete();
        return response('ok');
    }
    
    protected function getModel($id)
    {
        if (!$this->model) {
            $this->model = Model::find($id);
        }
        return $this->model;
    }
}
```

> **Подсказка**
> В конструкторе контроллера `__construct()` возврат данных не будет иметь никакого эффекта, например:

```php
<?php
namespace app\controller;

use support\Request;

class FooController
{
    public function __construct()
    {
        // Возврат данных в конструкторе не будет иметь никакого эффекта, браузер не получит это в ответ
        return response('hello'); 
    }
}
```

## Разница между повторным использованием и без повторного использования контроллера
Различия следующие:

#### Без повторного использования контроллера
Каждый запрос будет создавать новый экземпляр контроллера, который будет удален по окончании запроса и высвободит память. Это соответствует традиционному подходу работы фреймворка. Из-за частого создания и удаления контроллера производительность будет немного ниже по сравнению с повторным использованием контроллера (потеря производительности около 10% по результатам тестирования helloworld, но с учетом реального бизнеса это практически незаметно).

#### Повторное использование контроллера
При повторном использовании один экземпляр контроллера будет создаваться только один раз в процессе, и после завершения запроса этот экземпляр контроллера не будет уничтожен, а будет использоваться для последующих запросов в этом процессе. Это повышает производительность, но не соответствует привычному подходу работы для большинства разработчиков.

#### Ситуации, когда нельзя использовать повторное использование контроллера
Если запросы изменяют свойства контроллера, нельзя включать повторное использование контроллера, потому что изменение этих свойств скажется на последующих запросах.

Некоторым разработчикам нравится делать инициализацию для каждого запроса в конструкторе контроллера `__construct()`, и в этом случае нельзя использовать повторное использование контроллера, поскольку конструктор процесса будет вызываться только один раз, а не для каждого запроса.

