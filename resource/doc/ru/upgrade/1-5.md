# Руководство по обновлению до версии 1.5

**Перед обновлением обязательно сделайте резервную копию и выполните следующие команды для обновления:**
`composer require workerman/webman-framework ^1.5 -W && composer require webman/console ^1.2.12 && php webman install`

# Особенности и изменения функционала

Поддержка [корутины](https://www.workerman.net/doc/workerman/fiber.html) в workerman v5

> **Подсказка**
> workerman v5 требует PHP>=8.1
> Команда по обновлению workerman: `composer require workerman/workerman ^5.0.0 -W`
> Для корутин необходимо установить: `composer require revolt/event-loop ^1.0.0`

# Примеры
### Отложенный ответ

```php
<?php

namespace app\controller;

use support\Request;
use Workerman\Timer;

class TestController
{
    public function index(Request $request)
    {
        // Задержка на 1,5 секунды
        Timer::sleep(1.5);
        return $request->getRemoteIp();
    }
}
```
`Timer::sleep()` похож на `sleep()` в PHP, но в отличие от `sleep()` не блокирует процесс.

### Отправка HTTP-запроса

> **Внимание**
> Для этого необходимо установить: `composer require workerman/http-client ^2.0.0`

```php
<?php

namespace app\controller;

use support\Request;
use Workerman\Http\Client;

class TestController
{
    public function index(Request $request)
    {
        static $client;
        $client = $client ?: new Client();
        $response = $client->get('http://example.com'); // Асинхронный запрос с использованием синхронного метода
        return $response->getBody()->getContents();
    }
}
```
Такой же запрос `$client->get()` не блокирующий, что позволяет выполнять не блокирующую обработку HTTP-запросов в webman, повышая производительность.

Более подробно см. [workerman/http-client](https://www.workerman.net/doc/workerman/components/workerman-http-client.html)

### Добавление класса support\Context

Класс support\Context используется для хранения данных, связанных с запросом. При завершении запроса соответствующие данные контекста автоматически удаляются, что означает, что срок жизни данных контекста совпадает со сроком жизни запроса.

### Загрязнение глобальных переменных

В среде корутины запрещено хранить информацию о состоянии, связанную с запросом, в глобальных переменных или статических переменных, так как это может привести к загрязнению глобальных переменных, например,

```php
<?php

namespace app\controller;

use support\Request;
use Workerman\Timer;

class TestController
{
    protected static $name = '';

    public function index(Request $request)
    {
        static::$name = $request->get('name');
        Timer::sleep(5);
        return static::$name;
    }
}
```

Установив количество процессов в 1, когда мы выполняем два последовательных запроса
http://127.0.0.1:8787/test?name=lilei
http://127.0.0.1:8787/test?name=hanmeimei
мы ожидаем, что результаты двух запросов будут соответственно `lilei` и `hanmeimei`, но на самом деле оба запроса возвращают `hanmeimei`.
Это происходит потому, что второй запрос перезаписывает статическую переменную `$name`, и когда первый запрос завершается после ожидания, статическая переменная `$name` уже имеет значение `hanmeimei`.

**Правильным подходом является использование контекста для хранения данных о состоянии запроса**
```php
<?php

namespace app\controller;

use support\Request;
use support\Context;
use Workerman\Timer;

class TestController
{
    public function index(Request $request)
    {
        Context::set('name', $request->get('name'));
        Timer::sleep(5);
        return Context::get('name');
    }
}
```

**Локальные переменные не вызывают загрязнение данных**
```php
<?php

namespace app\controller;

use support\Request;
use support\Context;
use Workerman\Timer;

class TestController
{
    public function index(Request $request)
    {
        $name = $request->get('name');
        Timer::sleep(5);
        return $name;
    }
}
```
Поскольку `$name` является локальной переменной, корутины не могут взаимодействовать с локальными переменными друг друга, поэтому использование локальных переменных является безопасным для корутин.

# О корутинах
Корутины не являются универсальным решением, и внедрение их означает необходимость учесть проблему загрязнения глобальных переменных/статических переменных и установить контекст. Кроме того, отладка багов в среде корутин более сложна, чем в блокирующем программировании.

Заблокированное программирование в webman на самом деле уже достаточно быстро, как показывают данные из трех последних раундов тестирования производительности на [techempower.com](https://www.techempower.com/benchmarks/#section=data-r21&l=zijnjz-6bj&test=db&f=1ekg-cbcw-2t4w-27wr68-pc0-iv9slc-0-1ekgw-39g-kxs00-o0zk-4fu13d-2x8do8-2), где webman в блокирующем режиме с обработкой запросов к базе данных демонстрирует производительность почти в 2 раза выше чем у веб-фреймворков на go gin, echo, и почти в 40 раз выше, чем у традиционного фреймворка Laravel.
![](../../assets/img/benchemarks-go-sw.png?)

Когда база данных, redis находится в локальной сети, производительность блокированной программы часто превосходит производительность корутин из-за того, что расход на создание, планирование и уничтожение корутин может быть больше, чем расход на переключение процессов, при условии, что база данных, redis достаточно быстры. Поэтому ввод корутин в таких случаях не приводит к значительному увеличению производительности.

# Когда следует использовать корутины
Когда в бизнес-логике есть медленные запросы, например, при необходимости обращения к стороннему API, можно использовать [workerman/http-client](https://www.workerman.net/doc/workerman/components/workerman-http-client.html) для асинхронного выполнения HTTP-вызовов с помощью корутин, повышая параллельную способность приложения.
