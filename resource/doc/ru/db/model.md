# Быстрый старт

Модель webman основана на [Eloquent ORM](https://laravel.com/docs/7.x/eloquent) . Каждая таблица базы данных имеет соответствующую "модель", которая взаимодействует с этой таблицей. Вы можете использовать модель для запроса данных из таблицы и вставки новых записей в таблицу.

Прежде чем начать, убедитесь, что настроили подключение к базе данных в `config/database.php`.

> Примечание: Для поддержки наблюдателей моделей Eloquent ORM требуется дополнительный импорт `composer require "illuminate/events"` [Пример](#модель-наблюдателя)

## Пример
```php
<?php
namespace app\model;

use support\Model;

class User extends Model
{
    /**
     * Название связанной с моделью таблицы
     *
     * @var string
     */
    protected $table = 'user';

    /**
     * Переопределение первичного ключа, по умолчанию - id
     *
     * @var string
     */
    protected $primaryKey = 'uid';

    /**
     * Указывает, автоматически ли поддерживать время создания и обновления
     *
     * @var bool
     */
    public $timestamps = false;
}
```

## Название таблицы
Вы можете указать пользовательское название таблицы, определив атрибут table в модели:
```php
class User extends Model
{
    /**
     * Название связанной с моделью таблицы
     *
     * @var string
     */
    protected $table = 'user';
}
```

## Первичный ключ
Eloquent также предполагает, что каждая таблица данных имеет столбец первичного ключа с названием id. Вы можете определить защищенный атрибут $primaryKey для переопределения этого соглашения.
```php
class User extends Model
{
    /**
     * Переопределение первичного ключа, по умолчанию - id
     *
     * @var string
     */
    protected $primaryKey = 'uid';
}
```

Eloquent предполагает, что первичный ключ является автоинкрементируемым целочисленным значением, что означает, что по умолчанию первичный ключ будет автоматически преобразован в тип int. Если вы хотите использовать неувеличивающийся или нечисловой первичный ключ, вам нужно установить атрибут $incrementing как false:
```php
class User extends Model
{
    /**
     * Указывает, увеличивается ли первичный ключ модели
     *
     * @var bool
     */
    public $incrementing = false;
}
```

Если ваш первичный ключ не является целым числом, вам нужно установить защищенный атрибут $keyType как string:
```php
class User extends Model
{
    /**
     * "Тип" автоматически увеличиваемого ID.
     *
     * @var string
     */
    protected $keyType = 'string';
}
```

## Метки времени
По умолчанию Eloquent ожидает, что в вашей таблице данных есть created_at и updated_at. Если вы не хотите, чтобы Eloquent автоматически управлял этими двумя столбцами, установите атрибут $timestamps модели как false:
```php
class User extends Model
{
    /**
     * Указывает, автоматически ли поддерживать метки времени
     *
     * @var bool
     */
    public $timestamps = false;
}
```
Если вам нужно настроить формат меток времени, установите атрибут $dateFormat в вашей модели. Этот атрибут определяет формат хранения дат в базе данных, а также формат сериализации модели в массив или JSON:
```php
class User extends Model
{
    /**
     * Формат хранения меток времени
     *
     * @var string
     */
    protected $dateFormat = 'U';
}
```

Если вам нужно настроить названия полей для хранения меток времени, вы можете установить значения в модели для констант CREATED_AT и UPDATED_AT:
```php
class User extends Model
{
    const CREATED_AT = 'creation_date';
    const UPDATED_AT = 'last_update';
}
```

## Подключение к базе данных
По умолчанию модель Eloquent будет использовать конфигурацию базы данных, настроенную в вашем приложении. Если вы хотите указать для модели другое подключение, установите атрибут $connection:
```php
class User extends Model
{
    /**
     * Имя соединения модели
     *
     * @var string
     */
    protected $connection = 'connection-name';
}
```

## Значения по умолчанию
Если вы хотите определить значения по умолчанию для некоторых атрибутов модели, вы можете определить атрибут $attributes в модели:
```php
class User extends Model
{
    /**
     * Значения атрибутов модели по умолчанию.
     *
     * @var array
     */
    protected $attributes = [
        'delayed' => false,
    ];
}
```

## Поиск моделей
После создания модели и связанной с ней таблицы базы данных, вы можете запросить данные из базы данных. Представьте каждую модель Eloquent как мощный конструктор запросов, который можно использовать для быстрого запроса данных, связанных с этой моделью. Например:
```php
$users = app\model\User::all();

foreach ($users as $user) {
    echo $user->name;
}
```
> Подсказка: Поскольку модель Eloquent также является конструктором запросов, вы также должны ознакомиться со всеми методами, доступными в [Конструкторе запросов](queries.md) . Вы можете использовать эти методы в запросах Eloquent.

## Дополнительные ограничения
Метод all Eloquent вернет все результаты модели. Поскольку каждая модель Eloquent также является конструктором запросов, вы также можете добавить условия запроса, а затем использовать метод get для получения результатов запроса:
```php
$users = app\model\User::where('name', 'like', '%tom')
               ->orderBy('uid', 'desc')
               ->limit(10)
               ->get();
```

## Повторная загрузка модели
Вы можете использовать методы fresh и refresh для повторной загрузки модели. Метод fresh будет извлекать модель заново из базы данных, не затрагивая существующий экземпляр модели:
```php
$user = app\model\User::where('name', 'tom')->first();

$fresh_user = $user->fresh();
```

Метод refresh использует новые данные из базы данных для повторной загрузки существующей модели. Кроме того, предварительно загруженные отношения будут заново загружены:
```php
$user = app\model\User::where('name', 'tom')->first();

$user->name = 'jerry';

$user = $user->fresh();

$user->name; // "tom"
```

## Коллекция
Методы all и get Eloquent могут запросить несколько результатов и вернуть экземпляр `Illuminate\Database\Eloquent\Collection`. Класс `Collection` предоставляет множество вспомогательных функций для обработки результатов Eloquent:
```php
$users = $users->reject(function ($user) {
    return $user->disabled;
});
```

## Использование курсора
Метод cursor позволяет вам использовать курсор для итерации по базе данных, выполнение только одного запроса. При работе с большими объемами данных метод cursor может значительно сократить потребление памяти:
```php
foreach (app\model\User::where('sex', 1')->cursor() as $user) {
    //
}
```

Метод cursor возвращает экземпляр `Illuminate\Support\LazyCollection`. [Ленивые коллекции](https://laravel.com/docs/7.x/collections#lazy-collections) позволяют использовать множество методов коллекций Laravel и загружают только одну модель в память каждый раз:
```php
$users = app\model\User::cursor()->filter(function ($user) {
    return $user->id > 500;
});

foreach ($users as $user) {
    echo $user->id;
}
```

## Подзапросы Selects
Eloquent предоставляет поддержку высокоуровневых подзапросов, вы можете извлечь информацию из связанной таблицы с помощью одного запроса. Например, предположим у нас есть таблица назначений destinations и таблица рейсов flights, где таблица flights содержит поле arrival_at, указывающее, когда рейс прибывает в место назначения.

Используя методы select и addSelect функции поддерживаемые подзапросами, мы можем использовать один запрос для получения всех мест назначения destinations и имени последнего пребывающего туда рейса:
```php
use app\model\Destination;
use app\model\Flight;

return Destination::addSelect(['last_flight' => Flight::select('name')
    ->whereColumn('destination_id', 'destinations.id')
    ->orderBy('arrived_at', 'desc')
    ->limit(1)
])->get();
```
## Сортировка по подзапросу
Кроме того, метод orderBy конструктора запросов поддерживает подзапросы. Мы можем использовать эту функцию для сортировки всех мест назначения по времени последнего прибытия туда самолета. Таким образом, это позволяет выполнить только один запрос к базе данных:
```php
return Destination::orderByDesc(
    Flight::select('arrived_at')
        ->whereColumn('destination_id', 'destinations.id')
        ->orderBy('arrived_at', 'desc')
        ->limit(1)
)->get();
```

## Получение одной модели / коллекции
Помимо извлечения всех записей из указанной таблицы, вы можете использовать методы find, first или firstWhere для получения одной записи. Эти методы возвращают один экземпляр модели, а не коллекцию моделей:
```php
// Поиск модели по первичному ключу...
$flight = app\model\Flight::find(1);

// Поиск первой модели, удовлетворяющей условиям запроса...
$flight = app\model\Flight::where('active', 1)->first();

// Быстрый поиск первой модели, удовлетворяющей условиям запроса...
$flight = app\model\Flight::firstWhere('active', 1);
```

Также вы можете использовать массив первичных ключей в качестве параметра метода find, он вернет коллекцию записей, соответствующих найденным записям:
```php
$flights = app\model\Flight::find([1, 2, 3]);
```

Иногда вам может понадобиться выполнить другие действия, если не найдена первая запись, но вы хотите найти ее. Метод firstOr вернет первую запись, если она найдена, в случае отсутствия он выполнит заданный обратный вызов. Значение обратного вызова будет возвращено в качестве результата метода firstOr:
```php
$model = app\model\Flight::where('legs', '>', 100)->firstOr(function () {
        // ...
});
```
Метод firstOr также принимает массив полей для запроса:
```php
$model = app\modle\Flight::where('legs', '>', 100)
            ->firstOr(['id', 'legs'], function () {
                // ...
            });
```

## Исключение "Не найдено"
Иногда вы можете хотеть, чтобы при отсутствии модели было сгенерировано исключение. Это очень полезно в контроллерах и маршрутах. Методы findOrFail и firstOrFail извлекут первый результат запроса, если его не будет найдено, они сгенерируют исключение Illuminate\Database\Eloquent\ModelNotFoundException:
```php
$model = app\modle\Flight::findOrFail(1);
$model = app\modle\Flight::where('legs', '>', 100)->firstOrFail();
```
## Коллекция запросов
Вы также можете использовать методы count, sum и max, предоставленные строителем запросов, а также другие функции коллекции для операций над коллекциями. Эти методы вернут только соответствующие скалярные значения, а не экземпляр модели:
```php
$count = app\modle\Flight::where('active', 1)->count();

$max = app\modle\Flight::where('active', 1)->max('price');
```

## Вставка
Чтобы добавить запись в базу данных, сначала создайте новый экземпляр модели, установите ему атрибуты, а затем вызовите метод save:
```php
<?php

namespace app\controller;

use app\model\User;
use support\Request;
use support\Response;

class FooController
{
    /**
     * Добавление новой записи в таблицу пользователей
     *
     * @param  Request  $request
     * @return Response
     */
    public function store(Request $request)
    {
        // Проверка запроса

        $user = new User;

        $user->name = $request->get('name');

        $user->save();
    }
}
```

Временные метки created_at и updated_at будут установлены автоматически (если свойство $timestamps в модели установлено на true), необходимости вручной установки нет.

## Обновление
Метод save также может использоваться для обновления уже существующих моделей в базе данных. Чтобы обновить модель, вам необходимо сначала извлечь ее, установить нужные для обновления атрибуты, а затем вызвать метод save. Аналогично, временная метка updated_at будет автоматически обновлена, поэтому ручное присвоение не требуется:
```php
$user = app\model\User::find(1);
$user->name = 'jerry';
$user->save();
```

## Массовое обновление
```php
app\model\User::where('uid', '>', 10)
          ->update(['name' => 'tom']);
```

## Проверка изменений свойств
Eloquent предоставляет методы isDirty, isClean и wasChanged для проверки внутреннего состояния модели и определения изменения свойств с момента первоначальной загрузки. Метод isDirty определяет, были ли изменены какие-либо свойства с момента загрузки модели. Вы можете передать конкретное имя свойства, чтобы определить, изменилось ли конкретное свойство. Метод isClean работает наоборот и также принимает необязательное имя свойства:
```php
$user = User::create([
    'first_name' => 'Taylor',
    'last_name' => 'Otwell',
    'title' => 'Developer',
]);

$user->title = 'Painter';

$user->isDirty(); // true
$user->isDirty('title'); // true
$user->isDirty('first_name'); // false

$user->isClean(); // false
$user->isClean('title'); // false
$user->isClean('first_name'); // true

$user->save();

$user->isDirty(); // false
$user->isClean(); // true
```
Метод wasChanged определяет, были ли изменены свойства при последнем сохранении модели в текущем запросе. Вы также можете передать имя свойства, чтобы узнать, было ли изменено определенное свойство:
```php
$user = User::create([
    'first_name' => 'Taylor',
    'last_name' => 'Otwell',
    'title' => 'Developer',
]);

$user->title = 'Painter';
$user->save();

$user->wasChanged(); // true
$user->wasChanged('title'); // true
$user->wasChanged('first_name'); // false
```
## Массовое присвоение
Вы также можете использовать метод create для сохранения новых моделей. Этот метод вернет экземпляр модели. Однако перед использованием вам необходимо указать fillable или guarded атрибуты на модели, поскольку все модели Eloquent по умолчанию не поддерживают массовое присвоение.

Если пользователь передает ненужные параметры HTTP-запроса и эти параметры изменяют поля в базе данных, которые вам не нужно изменять, это может привести к уязвимости массового присвоения. Например, злонамеренный пользователь может передать параметр is_admin через HTTP-запрос, а затем передать его в метод create, что позволит пользователю повысить себя до администратора.

Поэтому перед тем, как начать, вам следует определить, какие атрибуты модели можно сохранять массово. Вы можете сделать это, определив атрибут $fillable на модели. Например, позволяет свойству name модели Flight присваиваться массово:
```php
<?php

namespace app\model;

use support\Model;

class Flight extends Model
{
    /**
     * Свойства модели, которым можно массово присваивать значения.
     *
     * @var array
     */
    protected $fillable = ['name'];
}

```
После того как вы установили, какие атрибуты можно массово присваивать, вы можете использовать метод create для вставки новых данных в базу данных. Метод create вернет сохраненный экземпляр модели:
```php
$flight = app\modle\Flight::create(['name' => 'Flight 10']);
```
Если у вас уже есть экземпляр модели, вы можете передать массив в метод fill для присвоения значений:
```php
$flight->fill(['name' => 'Flight 22']);
```

$fillable можно рассматривать как «белый список» для массового присвоения. Вы также можете использовать свойство $guarded. Свойство $guarded содержит массив атрибутов, которым не разрешено массовое присвоение. Другими словами, $guarded функционально больше похож на «черный список». Обратите внимание: вы можете использовать только $fillable или $guarded, но не одновременно. В следующем примере атрибут price, кроме атрибута price, можно присваивать массово:
```php
<?php

namespace app\model;

use support\Model;

class Flight extends Model
{
    /**
     * Атрибуты модели, которым нельзя массово присваивать значения.
     *
     * @var array
     */
    protected $guarded = ['price'];
}
```
Если вам нужно разрешить массовое присвоение для всех атрибутов, вы можете определить $guarded как пустой массив:
```php
/**
 * Атрибуты модели, которым нельзя массово присваивать значения.
 *
 * @var array
 */
protected $guarded = [];
```

## Другие методы создания
firstOrCreate/ firstOrNew
Здесь есть два метода, которые вы могли бы использовать для массового присвоения: firstOrCreate и firstOrNew. Метод firstOrCreate будет сопоставлять данные из базы данных с заданной парой ключ / значения. Если модель не будет найдена в базе данных, будет вставлена запись, содержащая атрибуты первого параметра и, при наличии, атрибуты второго параметра.
Метод firstOrNew похож на метод firstOrCreate и пытается найти запись в базе данных на основе заданных атрибутов. Однако, если метод firstOrNew не найдет соответствующей модели, он вернет новый экземпляр модели. Обратите внимание, что экземпляр, возвращаемый firstOrNew, еще не сохранен в базе данных, и вам нужно вызвать метод save вручную:
```php
// Поиск рейса по имени или создание нового, если не найден...
$flight = app\modle\Flight::firstOrCreate(['name' => 'Flight 10']);

// Поиск рейса по имени или создание нового с атрибутами name и delayed и arrival_time...
$flight = app\modle\Flight::firstOrCreate(
    ['name' => 'Flight 10'],
    ['delayed' => 1, 'arrival_time' => '11:30']
);

// Поиск рейса по имени или создание нового экземпляра...
$flight = app\modle\Flight::firstOrNew(['name' => 'Flight 10']);

// Поиск рейса по имени или создание нового экземпляра с атрибутами name и delayed и arrival_time...
$flight = app\modle\Flight::firstOrNew(
    ['name' => 'Flight 10'],
    ['delayed' => 1, 'arrival_time' => '11:30']
);

```

Вы также можете столкнуться с ситуациями, когда вы хотите обновить существующую модель или создать новую модель, если ее не существует. Метод updateOrCreate предлагает решение за один шаг. Подобно методу firstOrCreate, updateOrCreate сохраняет модель поэтому не требуется вызывать save():
```php
// Если существует рейс из Окленда в Сан-Диего, то устанавливаем цену на 99 долларов.
// Если соответствующей модели не обнаружено, мы создаем новую.
$flight = app\modle\Flight::updateOrCreate(
    ['departure' => 'Oakland', 'destination' => 'San Diego'],
    ['price' => 99, 'discounted' => 1]
);

```

## Удаление модели

Вы можете вызвать метод delete на экземпляре модели, чтобы удалить его:
```php
$flight = app\modle\Flight::find(1);
$flight->delete();
```

## Удаление модели по ключу
```php
app\modle\Flight::destroy(1);

app\modle\Flight::destroy(1, 2, 3);

app\modle\Flight::destroy([1, 2, 3]);

app\modle\Flight::destroy(collect([1, 2, 3]));

```

## Удаление модели по запросу
```php
$deletedRows = app\modle\Flight::where('active', 0)->delete();
```

## Копирование модели
Вы можете использовать метод replicate для создания нового экземпляра, который еще не был сохранен в базе данных. Этот метод особенно удобен, когда экземпляры модели имеют много общих атрибутов.
```php
$shipping = App\Address::create([
    'type' => 'shipping',
    'line_1' => '123 Example Street',
    'city' => 'Victorville',
    'state' => 'CA',
    'postcode' => '90001',
]);

$billing = $shipping->replicate()->fill([
    'type' => 'billing'
]);

$billing->save();

```

## Сравнение моделей
Иногда вам может потребоваться определить, «равны» ли две модели. Метод is можно использовать для быстрой проверки, имеют ли две модели одинаковые ключи, таблицы и соединения с базой данных:
```php
if ($post->is($anotherPost)) {
    //
}
```


## Наблюдатели моделей

Используйте [События модели и наблюдатель в Laravel](https://learnku.com/articles/6657/model-events-and-observer-in-laravel)

Примечание: для поддержки наблюдателей моделей Eloquent ORM требуется дополнительный импорт с помощью композера require "illuminate/events"

```php
<?php
namespace app\model;

use support\Model;
use app\observer\UserObserver;

class User extends Model
{
    public static function boot()
    {
        parent::boot();
        static::observe(UserObserver::class);
    }
}
```
